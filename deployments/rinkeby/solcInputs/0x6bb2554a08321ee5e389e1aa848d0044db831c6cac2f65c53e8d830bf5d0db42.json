{
  "language": "Solidity",
  "sources": {
    "contracts/distribution/RewardsDistributionRecipient.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract RewardsDistributionRecipient {\n  address public immutable rewardsDistribution;\n\n  function notifyRewardAmount(uint256 reward) external virtual;\n\n  constructor(address rewardsDistribution_) public {\n    rewardsDistribution = rewardsDistribution_;\n  }\n\n  modifier onlyRewardsDistribution() {\n    require(\n      msg.sender == rewardsDistribution,\n      \"Caller is not RewardsDistribution contract\"\n    );\n    _;\n  }\n}\n"
    },
    "contracts/distribution/StakingRewards.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n// Inheritance\nimport \"../interfaces/IStakingRewards.sol\";\nimport \"./RewardsDistributionRecipient.sol\";\n\n\ncontract StakingRewards is\n  IStakingRewards,\n  RewardsDistributionRecipient,\n  ReentrancyGuard\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== IMMUTABLES ========== */\n  IERC20 public immutable rewardsToken;\n\n  /* ========== STATE VARIABLES ========== */\n\n  IERC20 public stakingToken;\n  uint256 public periodFinish = 0;\n  uint256 public rewardRate = 0;\n  uint256 public rewardsDuration = 60 days;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n\n  uint256 private _totalSupply;\n  mapping(address => uint256) private _balances;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    address rewardsDistribution_,\n    address rewardsToken_\n  ) public RewardsDistributionRecipient(rewardsDistribution_) {\n    rewardsToken = IERC20(rewardsToken_);\n  }\n\n  function initialize(address stakingToken_) external {\n    require(address(stakingToken) == address(0), \"ERR_INITIALIZED\");\n    stakingToken = IERC20(stakingToken_);\n  }\n\n  /* ========== VIEWS ========== */\n\n  function totalSupply() external override view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external override view returns (uint256) {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable() public override view returns (uint256) {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  function rewardPerToken() public override view returns (uint256) {\n    if (_totalSupply == 0) {\n      return rewardPerTokenStored;\n    }\n    return\n      rewardPerTokenStored.add(\n        lastTimeRewardApplicable()\n          .sub(lastUpdateTime)\n          .mul(rewardRate)\n          .mul(1e18)\n          .div(_totalSupply)\n      );\n  }\n\n  function earned(address account) public override view returns (uint256) {\n    return _balances[account]\n      .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n      .div(1e18)\n      .add(rewards[account]);\n  }\n\n  function getRewardForDuration() external override view returns (uint256) {\n    return rewardRate.mul(rewardsDuration);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function stake(uint256 amount)\n    external\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"Cannot stake 0\");\n    _totalSupply = _totalSupply.add(amount);\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n    stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    emit Staked(msg.sender, amount);\n  }\n\n  function withdraw(uint256 amount)\n    public\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"Cannot withdraw 0\");\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    stakingToken.safeTransfer(msg.sender, amount);\n    emit Withdrawn(msg.sender, amount);\n  }\n\n  function getReward()\n    public\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    uint256 reward = rewards[msg.sender];\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      rewardsToken.safeTransfer(msg.sender, reward);\n      emit RewardPaid(msg.sender, reward);\n    }\n  }\n\n  function exit() external override {\n    withdraw(_balances[msg.sender]);\n    getReward();\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function notifyRewardAmount(uint256 reward)\n    external\n    override\n    onlyRewardsDistribution\n    updateReward(address(0))\n  {\n    if (block.timestamp >= periodFinish) {\n      rewardRate = reward.div(rewardsDuration);\n    } else {\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftover = remaining.mul(rewardRate);\n      rewardRate = reward.add(leftover).div(rewardsDuration);\n    }\n\n    // Ensure the provided reward amount is not more than the balance in the contract.\n    // This keeps the reward rate in the right range, preventing overflows due to\n    // very high values of rewardRate in the earned and rewardsPerToken functions;\n    // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n    uint256 balance = rewardsToken.balanceOf(address(this));\n    require(\n      rewardRate <= balance.div(rewardsDuration),\n      \"Provided reward too high\"\n    );\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp.add(rewardsDuration);\n    emit RewardAdded(reward);\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 amount);\n  event Withdrawn(address indexed user, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface IStakingRewards {\n  // Views\n  function lastTimeRewardApplicable() external view returns (uint256);\n\n  function rewardPerToken() external view returns (uint256);\n\n  function earned(address account) external view returns (uint256);\n\n  function getRewardForDuration() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  // Mutative\n\n  function stake(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n\n  function getReward() external;\n\n  function exit() external;\n}\n"
    },
    "contracts/distribution/StakingRewardsFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/IDelegateCallProxyManager.sol\";\n\nimport \"../lib/Owned.sol\";\n\n\ncontract StakingRewardsFactory is Owned {\n  bytes32 public constant STAKING_REWARDS_IMPLEMENTATION_ID = keccak256(\"StakingRewards.sol\");\n\n  // immutables\n  DelegateCallProxyManager public immutable proxyManager;\n  address public immutable rewardsToken;\n  uint public immutable stakingRewardsGenesis;\n\n  // the staking tokens for which the rewards contract has been deployed\n  address[] public stakingTokens;\n\n\n  // info about rewards for a particular staking token\n  struct StakingRewardsInfo {\n    address stakingRewards;\n    uint rewardAmount;\n  }\n\n  // rewards info by staking token\n  mapping(address => StakingRewardsInfo) public stakingRewardsInfoByStakingToken;\n\n  constructor(\n    address owner_,\n    address rewardsToken_,\n    uint stakingRewardsGenesis_,\n    address proxyManager_\n  ) public Owned(owner_) {\n    rewardsToken = rewardsToken_;\n    stakingRewardsGenesis = stakingRewardsGenesis_;\n    proxyManager = DelegateCallProxyManager(proxyManager_);\n  }\n\n  function deploy(address stakingToken) external _owner_ {\n    \n  }\n}"
    },
    "contracts/interfaces/IPoolFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface IPoolFactory {\n  function isIPool(address pool) external view returns (bool);\n}"
    },
    "contracts/interfaces/IDelegateCallProxyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\n *\n * An implementation identifier can be created on the proxy manager which is\n * used to specify the logic address for a particular contract type, and to\n * upgrade the implementation as needed.\n *\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\n * address.\n *\n * A many-to-one proxy is a single upgradeable implementation address that may be\n * used by many proxy contracts.\n */\ninterface DelegateCallProxyManager {\n/* ---  Events  --- */\n\n  event DeploymentApprovalGranted(address deployer);\n  event DeploymentApprovalRevoked(address deployer);\n\n  event ManyToOne_ImplementationCreated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ImplementationUpdated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ProxyDeployed(\n    bytes32 implementationID,\n    address proxyAddress\n  );\n\n  event OneToOne_ProxyDeployed(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n  event OneToOne_ImplementationUpdated(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n/* ---  Controls  --- */\n\n  /**\n   * @dev Allows `deployer` to deploy many-to-one proxies.\n   */\n  function approveDeployer(address deployer) external;\n\n  /**\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\n   */\n  function revokeDeployerApproval(address deployer) external;\n\n/* ---  Implementation Management  --- */\n\n  /**\n   * @dev Creates a many-to-one proxy relationship.\n   *\n   * Deploys an implementation holder contract which stores the\n   * implementation address for many proxies. The implementation\n   * address can be updated on the holder to change the runtime\n   * code used by all its proxies.\n   *\n   * @param implementationID ID for the implementation, used to identify the\n   * proxies that use it. Also used as the salt in the create2 call when\n   * deploying the implementation holder contract.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function createManyToOneProxyRelationship(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a many-to-one\n   * proxy relationship.\n   *\n   * @param implementationID Identifier for the implementation.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function setImplementationAddressManyToOne(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a one-to-one proxy.\n   *\n   * Note: This could work for many-to-one as well if the caller\n   * provides the implementation holder address in place of the\n   * proxy address, as they use the same access control and update\n   * mechanism.\n   *\n   * @param proxyAddress Address of the deployed proxy\n   * @param implementation Address with the runtime code for\n   * the proxy to use.\n   */\n  function setImplementationAddressOneToOne(\n    address proxyAddress,\n    address implementation\n  ) external;\n\n/* ---  Proxy Deployment  --- */\n\n  /**\n   * @dev Deploy a proxy contract with a one-to-one relationship\n   * with its implementation.\n   *\n   * The proxy will have its own implementation address which can\n   * be updated by the proxy manager.\n   *\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy should use.\n   */\n  function deployProxyOneToOne(\n    bytes32 suppliedSalt,\n    address implementation\n  ) external returns(address proxyAddress);\n\n  /**\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\n   *\n   * The proxy will call the implementation holder for every transaction to\n   * determine the address to use in calls.\n   *\n   * @param implementationID Identifier for the proxy's implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deployProxyManyToOne(\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external returns(address proxyAddress);\n\n/* ---  Queries  --- */\n\n  function isApprovedDeployer(address deployer) external view;\n\n  /**\n   * @dev Queries the temporary storage value `_implementationHolder`.\n   * This is used in the constructor of the many-to-one proxy contract\n   * so that the create2 address is static (adding constructor arguments\n   * would change the codehash) and the implementation holder can be\n   * stored as a constant.\n   */\n  function getImplementationHolder() external view returns (address);\n\n  /**\n   * @dev Returns the address of the implementation holder contract\n   * for `implementationID`.\n   */\n  function getImplementationHolder(bytes32 implementationID) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy requested\n   * by `originator` using `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address originator,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(bytes32 implementationID) external view returns (address);\n}"
    },
    "contracts/lib/Owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\ncontract Owned {\n  event OwnerSet(address newOwner);\n\n  address internal _owner;\n\n  modifier _owner_ {\n    require(msg.sender == _owner, \"ERR_NOT_OWNER\");\n    _;\n  }\n\n  constructor(address owner) public {\n    _owner = owner;\n  }\n\n  function getOwner() external view returns (address) {\n    return _owner;\n  }\n\n  function setOwner(address owner) external _owner_ {\n    require(owner != address(0), \"ERR_NULL_ADDRESS\");\n    _owner = owner;\n    emit OwnerSet(owner);\n  }\n}"
    },
    "contracts/distribution/TreasuryVester.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract TreasuryVester {\n  using SafeMath for uint256;\n\n  address public uni;\n  address public recipient;\n\n  uint256 public vestingAmount;\n  uint256 public vestingBegin;\n  uint256 public vestingCliff;\n  uint256 public vestingEnd;\n\n  uint256 public lastUpdate;\n\n  constructor(\n    address uni_,\n    address recipient_,\n    uint256 vestingAmount_,\n    uint256 vestingBegin_,\n    uint256 vestingCliff_,\n    uint256 vestingEnd_\n  ) public {\n    require(\n      vestingBegin_ >= block.timestamp,\n      \"TreasuryVester::constructor: vesting begin too early\"\n    );\n    require(\n      vestingCliff_ >= vestingBegin_,\n      \"TreasuryVester::constructor: cliff is too early\"\n    );\n    require(\n      vestingEnd_ > vestingCliff_,\n      \"TreasuryVester::constructor: end is too early\"\n    );\n\n    uni = uni_;\n    recipient = recipient_;\n\n    vestingAmount = vestingAmount_;\n    vestingBegin = vestingBegin_;\n    vestingCliff = vestingCliff_;\n    vestingEnd = vestingEnd_;\n\n    lastUpdate = vestingBegin;\n  }\n\n  function setRecipient(address recipient_) public {\n    require(\n      msg.sender == recipient,\n      \"TreasuryVester::setRecipient: unauthorized\"\n    );\n    recipient = recipient_;\n  }\n\n  function claim() public {\n    require(\n      block.timestamp >= vestingCliff,\n      \"TreasuryVester::claim: not time yet\"\n    );\n    uint256 amount;\n    if (block.timestamp >= vestingEnd) {\n      amount = INdx(uni).balanceOf(address(this));\n    } else {\n      amount = vestingAmount.mul(block.timestamp - lastUpdate).div(\n        vestingEnd - vestingBegin\n      );\n      lastUpdate = block.timestamp;\n    }\n    INdx(uni).transfer(recipient, amount);\n  }\n}\n\ninterface INdx {\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address dst, uint256 rawAmount) external returns (bool);\n}\n"
    },
    "contracts/governance/GovernorAlpha.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract GovernorAlpha {\n  /// @notice The name of this contract\n  string public constant name = \"Indexed Governor Alpha\";\n\n  /**\n   * @notice The number of votes in support of a proposal required in order for a\n   * quorum to be reached and for a vote to succeed\n   */ \n  function quorumVotes() public pure returns (uint256) {\n    return 40_000_000e18;\n  }\n\n  function proposalThreshold() public pure returns (uint256) {\n    return 10_000_000e18;\n  }\n\n  function proposalMaxOperations() public pure returns (uint256) {\n    return 10;\n  }\n\n  function votingDelay() public pure returns (uint256) {\n    return 1;\n  }\n\n  function votingPeriod() public pure returns (uint256) {\n    return 40_320;\n  }\n\n  TimelockInterface public timelock;\n\n  NdxInterface public ndx;\n\n  uint256 public proposalCount;\n\n  struct Proposal {\n    uint256 id;\n    address proposer;\n    uint256 eta;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    bool canceled;\n    bool executed;\n    mapping(address => Receipt) receipts;\n  }\n\n  struct Receipt {\n    bool hasVoted;\n    bool support;\n    uint96 votes;\n  }\n\n  enum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n  }\n\n  mapping(uint256 => Proposal) public proposals;\n\n  mapping(address => uint256) public latestProposalIds;\n\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n    \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n  );\n\n  bytes32 public constant BALLOT_TYPEHASH = keccak256(\n    \"Ballot(uint256 proposalId,bool support)\"\n  );\n\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startBlock,\n    uint256 endBlock,\n    string description\n  );\n\n  event VoteCast(\n    address voter,\n    uint256 proposalId,\n    bool support,\n    uint256 votes\n  );\n\n  event ProposalCanceled(uint256 id);\n\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  event ProposalExecuted(uint256 id);\n\n  constructor(address timelock_, address uni_) public {\n    timelock = TimelockInterface(timelock_);\n    ndx = NdxInterface(uni_);\n  }\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n  ) public returns (uint256) {\n    require(\n      ndx.getPriorVotes(msg.sender, sub256(block.number, 1)) >\n        proposalThreshold(),\n      \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n    );\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(\n      targets.length != 0,\n      \"GovernorAlpha::propose: must provide actions\"\n    );\n    require(\n      targets.length <= proposalMaxOperations(),\n      \"GovernorAlpha::propose: too many actions\"\n    );\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n      );\n      require(\n        proposersLatestProposalState != ProposalState.Pending,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n      );\n    }\n\n    uint256 startBlock = add256(block.number, votingDelay());\n    uint256 endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    Proposal memory newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: targets,\n      values: values,\n      signatures: signatures,\n      calldatas: calldatas,\n      startBlock: startBlock,\n      endBlock: endBlock,\n      forVotes: 0,\n      againstVotes: 0,\n      canceled: false,\n      executed: false\n    });\n\n    proposals[newProposal.id] = newProposal;\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      startBlock,\n      endBlock,\n      description\n    );\n    return newProposal.id;\n  }\n\n  function queue(uint256 proposalId) public {\n    require(\n      state(proposalId) == ProposalState.Succeeded,\n      \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    uint256 eta = add256(block.timestamp, timelock.delay());\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        eta\n      );\n    }\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n  }\n\n  function _queueOrRevert(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) internal {\n    require(\n      !timelock.queuedTransactions(\n        keccak256(abi.encode(target, value, signature, data, eta))\n      ),\n      \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n    );\n    timelock.queueTransaction(target, value, signature, data, eta);\n  }\n\n  function execute(uint256 proposalId) public payable {\n    require(\n      state(proposalId) == ProposalState.Queued,\n      \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.executeTransaction.value(proposal.values[i])(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n    emit ProposalExecuted(proposalId);\n  }\n\n  function cancel(uint256 proposalId) public {\n    ProposalState state = state(proposalId);\n    require(\n      state != ProposalState.Executed,\n      \"GovernorAlpha::cancel: cannot cancel executed proposal\"\n    );\n\n    Proposal storage proposal = proposals[proposalId];\n    require(\n      ndx.getPriorVotes(proposal.proposer, sub256(block.number, 1)) <\n        proposalThreshold(),\n      \"GovernorAlpha::cancel: proposer above threshold\"\n    );\n\n    proposal.canceled = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.cancelTransaction(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  function getActions(uint256 proposalId)\n    public\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    )\n  {\n    Proposal storage p = proposals[proposalId];\n    return (p.targets, p.values, p.signatures, p.calldatas);\n  }\n\n  function getReceipt(uint256 proposalId, address voter)\n    public\n    view\n    returns (Receipt memory)\n  {\n    return proposals[proposalId].receipts[voter];\n  }\n\n  function state(uint256 proposalId) public view returns (ProposalState) {\n    require(\n      proposalCount >= proposalId && proposalId > 0,\n      \"GovernorAlpha::state: invalid proposal id\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n      return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n      return ProposalState.Active;\n    } else if (\n      proposal.forVotes <= proposal.againstVotes ||\n      proposal.forVotes < quorumVotes()\n    ) {\n      return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (\n      block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())\n    ) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function castVote(uint256 proposalId, bool support) public {\n    return _castVote(msg.sender, proposalId, support);\n  }\n\n  function castVoteBySig(\n    uint256 proposalId,\n    bool support,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(BALLOT_TYPEHASH, proposalId, support)\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(\n      signatory != address(0),\n      \"GovernorAlpha::castVoteBySig: invalid signature\"\n    );\n    return _castVote(signatory, proposalId, support);\n  }\n\n  function _castVote(\n    address voter,\n    uint256 proposalId,\n    bool support\n  ) internal {\n    require(\n      state(proposalId) == ProposalState.Active,\n      \"GovernorAlpha::_castVote: voting is closed\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(\n      receipt.hasVoted == false,\n      \"GovernorAlpha::_castVote: voter already voted\"\n    );\n    uint96 votes = ndx.getPriorVotes(voter, proposal.startBlock);\n\n    if (support) {\n      proposal.forVotes = add256(proposal.forVotes, votes);\n    } else {\n      proposal.againstVotes = add256(proposal.againstVotes, votes);\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n  }\n\n  function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"addition overflow\");\n    return c;\n  }\n\n  function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"subtraction underflow\");\n    return a - b;\n  }\n\n  function getChainId() internal pure returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n\ninterface TimelockInterface {\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function acceptAdmin() external;\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n}\n\ninterface NdxInterface {\n  function getPriorVotes(address account, uint256 blockNumber)\n    external\n    view\n    returns (uint96);\n}\n"
    },
    "contracts/governance/Ndx.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Ndx {\n  /// @notice EIP-20 token name for this token\n  string public constant name = \"Indexed\";\n\n  /// @notice EIP-20 token symbol for this token\n  string public constant symbol = \"NDX\";\n\n  /// @notice EIP-20 token decimals for this token\n  uint8 public constant decimals = 18;\n\n  /// @notice Total number of tokens in circulation\n  uint256 public totalSupply = 1_000_000_000e18;\n\n  mapping(address => mapping(address => uint96)) internal allowances;\n\n  mapping(address => uint96) internal balances;\n\n  mapping(address => address) public delegates;\n\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n\n  mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n  mapping(address => uint32) public numCheckpoints;\n\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n    \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n  );\n\n  bytes32 public constant DELEGATION_TYPEHASH = keccak256(\n    \"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"\n  );\n\n  bytes32 public constant PERMIT_TYPEHASH = keccak256(\n    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n  );\n\n  mapping(address => uint256) public nonces;\n\n  event DelegateChanged(\n    address indexed delegator,\n    address indexed fromDelegate,\n    address indexed toDelegate\n  );\n\n  event DelegateVotesChanged(\n    address indexed delegate,\n    uint256 previousBalance,\n    uint256 newBalance\n  );\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n\n  constructor(address account) public {\n    balances[account] = uint96(totalSupply);\n    emit Transfer(address(0), account, totalSupply);\n  }\n\n  function allowance(address account, address spender)\n    external\n    view\n    returns (uint256)\n  {\n    return allowances[account][spender];\n  }\n\n  function approve(address spender, uint256 rawAmount) external returns (bool) {\n    uint96 amount;\n    if (rawAmount == uint256(-1)) {\n      amount = uint96(-1);\n    } else {\n      amount = safe96(rawAmount, \"Ndx::approve: amount exceeds 96 bits\");\n    }\n\n    allowances[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 rawAmount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    uint96 amount;\n    if (rawAmount == uint256(-1)) {\n      amount = uint96(-1);\n    } else {\n      amount = safe96(rawAmount, \"Ndx::permit: amount exceeds 96 bits\");\n    }\n\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        rawAmount,\n        nonces[owner]++,\n        deadline\n      )\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Ndx::permit: invalid signature\");\n    require(signatory == owner, \"Ndx::permit: unauthorized\");\n    require(now <= deadline, \"Ndx::permit: signature expired\");\n\n    allowances[owner][spender] = amount;\n\n    emit Approval(owner, spender, amount);\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return balances[account];\n  }\n\n  function nonceOf(address account) external view returns (uint256) {\n    return nonces[account];\n  }\n\n  function transfer(address dst, uint256 rawAmount) external returns (bool) {\n    uint96 amount = safe96(rawAmount, \"Ndx::transfer: amount exceeds 96 bits\");\n    _transferTokens(msg.sender, dst, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 rawAmount\n  ) external returns (bool) {\n    address spender = msg.sender;\n    uint96 spenderAllowance = allowances[src][spender];\n    uint96 amount = safe96(rawAmount, \"Ndx::approve: amount exceeds 96 bits\");\n\n    if (spender != src && spenderAllowance != uint96(-1)) {\n      uint96 newAllowance = sub96(\n        spenderAllowance,\n        amount,\n        \"Ndx::transferFrom: transfer amount exceeds spender allowance\"\n      );\n      allowances[src][spender] = newAllowance;\n\n      emit Approval(src, spender, newAllowance);\n    }\n\n    _transferTokens(src, dst, amount);\n    return true;\n  }\n\n  function delegate(address delegatee) public {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Ndx::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"Ndx::delegateBySig: invalid nonce\");\n    require(now <= expiry, \"Ndx::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n  function getCurrentVotes(address account) external view returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  function getPriorVotes(address account, uint256 blockNumber)\n    public\n    view\n    returns (uint96)\n  {\n    require(\n      blockNumber < block.number,\n      \"Ndx::getPriorVotes: not yet determined\"\n    );\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n      return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint32 center = upper - (upper - lower) / 2;\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock < blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _transferTokens(\n    address src,\n    address dst,\n    uint96 amount\n  ) internal {\n    require(\n      src != address(0),\n      \"Ndx::_transferTokens: cannot transfer from the zero address\"\n    );\n    require(\n      dst != address(0),\n      \"Ndx::_transferTokens: cannot transfer to the zero address\"\n    );\n\n    balances[src] = sub96(\n      balances[src],\n      amount,\n      \"Ndx::_transferTokens: transfer amount exceeds balance\"\n    );\n    balances[dst] = add96(\n      balances[dst],\n      amount,\n      \"Ndx::_transferTokens: transfer amount overflows\"\n    );\n    emit Transfer(src, dst, amount);\n\n    _moveDelegates(delegates[src], delegates[dst], amount);\n  }\n\n  function _moveDelegates(\n    address srcRep,\n    address dstRep,\n    uint96 amount\n  ) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum > 0\n          ? checkpoints[srcRep][srcRepNum - 1].votes\n          : 0;\n        uint96 srcRepNew = sub96(\n          srcRepOld,\n          amount,\n          \"Ndx::_moveVotes: vote amount underflows\"\n        );\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum > 0\n          ? checkpoints[dstRep][dstRepNum - 1].votes\n          : 0;\n        uint96 dstRepNew = add96(\n          dstRepOld,\n          amount,\n          \"Ndx::_moveVotes: vote amount overflows\"\n        );\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    address delegatee,\n    uint32 nCheckpoints,\n    uint96 oldVotes,\n    uint96 newVotes\n  ) internal {\n    uint32 blockNumber = safe32(\n      block.number,\n      \"Ndx::_writeCheckpoint: block number exceeds 32 bits\"\n    );\n\n    if (\n      nCheckpoints > 0 &&\n      checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n    ) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint256 n, string memory errorMessage)\n    internal\n    pure\n    returns (uint32)\n  {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function safe96(uint256 n, string memory errorMessage)\n    internal\n    pure\n    returns (uint96)\n  {\n    require(n < 2**96, errorMessage);\n    return uint96(n);\n  }\n\n  function add96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function getChainId() internal pure returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n"
    },
    "contracts/governance/Timelock.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract Timelock {\n  using SafeMath for uint256;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  uint256 public constant GRACE_PERIOD = 14 days;\n  uint256 public constant MINIMUM_DELAY = 2 days;\n  uint256 public constant MAXIMUM_DELAY = 30 days;\n\n  address public admin;\n  address public pendingAdmin;\n  uint256 public delay;\n\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  constructor(address admin_, uint256 delay_) public {\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::constructor: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  fallback() external payable {}\n\n  function setDelay(uint256 delay_) public {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setDelay: Call must come from Timelock.\"\n    );\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::setDelay: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public {\n    require(\n      msg.sender == pendingAdmin,\n      \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n    );\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n    );\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public returns (bytes32) {\n    require(\n      msg.sender == admin,\n      \"Timelock::queueTransaction: Call must come from admin.\"\n    );\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public {\n    require(\n      msg.sender == admin,\n      \"Timelock::cancelTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable returns (bytes memory) {\n    require(\n      msg.sender == admin,\n      \"Timelock::executeTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(\n      queuedTransactions[txHash],\n      \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockTimestamp() >= eta,\n      \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n      \"Timelock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call.value(value)(\n      callData\n    );\n    require(\n      success,\n      \"Timelock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint256) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Detailed {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/lib/SafeDecimalMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n  using SafeMath for uint256;\n\n  /* Number of decimal places in the representations. */\n  uint8 public constant decimals = 18;\n  uint8 public constant highPrecisionDecimals = 27;\n\n  /* The number representing 1.0. */\n  uint256 public constant UNIT = 10**uint256(decimals);\n\n  /* The number representing 1.0 for higher fidelity numbers. */\n  uint256 public constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\n  uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10 ** uint256(\n    highPrecisionDecimals - decimals\n  );\n\n  /**\n   * @return Provides an interface to UNIT.\n   */\n  function unit() external pure returns (uint256) {\n    return UNIT;\n  }\n\n  /**\n   * @return Provides an interface to PRECISE_UNIT.\n   */\n  function preciseUnit() external pure returns (uint256) {\n    return PRECISE_UNIT;\n  }\n\n  /**\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\n   * decimals.\n   *\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\n   * so that product must be less than 2**256. As this is an integer division,\n   * the internal division always rounds down. This helps save on gas. Rounding\n   * is more expensive on gas.\n   */\n  function multiplyDecimal(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    return x.mul(y) / UNIT;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of the specified precision unit.\n   *\n   * @dev The operands should be in the form of a the specified unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function _multiplyDecimalRound(\n    uint256 x,\n    uint256 y,\n    uint256 precisionUnit\n  ) private pure returns (uint256) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a precise unit.\n   *\n   * @dev The operands should be in the precise unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRoundPrecise(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a standard unit.\n   *\n   * @dev The operands should be in the standard unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRound(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _multiplyDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is a high\n   * precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\n   * this is an integer division, the result is always rounded down.\n   * This helps save on gas. Rounding is more expensive on gas.\n   */\n  function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n    /* Reintroduce the UNIT factor that will be divided out by y. */\n    return x.mul(UNIT).div(y);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * decimal in the precision unit specified in the parameter.\n   *\n   * @dev y is divided after the product of x and the specified precision unit\n   * is evaluated, so the product of x and the specified precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function _divideDecimalRound(\n    uint256 x,\n    uint256 y,\n    uint256 precisionUnit\n  ) private pure returns (uint256) {\n    uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n    if (resultTimesTen % 10 >= 5) {\n      resultTimesTen += 10;\n    }\n\n    return resultTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * standard precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and the standard precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRound(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _divideDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * high precision decimal.\n   *\n   * @dev y is divided after the product of x and the high precision unit\n   * is evaluated, so the product of x and the high precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRoundPrecise(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Convert a standard decimal representation to a high precision one.\n   */\n  function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\n    return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n  }\n\n  /**\n   * @dev Convert a high precision decimal to a standard decimal representation.\n   */\n  function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\n    uint256 quotientTimesTen = i /\n      (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}
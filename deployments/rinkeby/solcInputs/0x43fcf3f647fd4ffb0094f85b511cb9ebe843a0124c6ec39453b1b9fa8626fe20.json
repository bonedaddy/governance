{
  "language": "Solidity",
  "sources": {
    "contracts/distribution/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/*\nCopyright 2020 Compound Labs, Inc.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that\nthe following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the\nfollowing disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and\nthe following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or\npromote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/**\n * @title Reservoir Contract\n * @dev Distributes a token to a different contract at a fixed rate.\n * @dev This contract must be poked via the `drip()` function every so often.\n * @author Compound\n */\ncontract Reservoir {\n  using SafeERC20 for IERC20;\n\n  /**\n   * @dev The block number when the Reservoir started (immutable)\n   */\n  uint public immutable dripStart;\n\n  /**\n   * @dev Tokens per block that to drip to target (immutable)\n   */\n  uint public immutable dripRate;\n\n  /**\n   * @dev Reference to token to drip (immutable)\n   */\n  IERC20 public immutable token;\n\n  /**\n   * @dev Target to receive dripped tokens (immutable)\n   */\n  address public immutable target;\n\n  /**\n   * @dev Amount that has already been dripped\n   */\n  uint public dripped;\n\n  /**\n    * @dev Constructs a Reservoir\n    * @param dripRate_ Numer of tokens per block to drip\n    * @param token_ The token to drip\n    * @param target_ The recipient of dripped tokens\n    */\n  constructor(uint dripRate_, IERC20 token_, address target_) public {\n    dripStart = block.number;\n    dripRate = dripRate_;\n    token = token_;\n    target = target_;\n    dripped = 0;\n  }\n\n  /**\n    * @dev Drips the maximum amount of tokens to match the drip rate since inception\n    * @dev Note: this will only drip up to the amount of tokens available.\n    * @return The amount of tokens dripped in this call\n    */\n  function drip() public returns (uint) {\n    // First, read storage into memory\n    IERC20 token_ = token;\n    uint reservoirBalance_ = token_.balanceOf(address(this));\n    uint dripRate_ = dripRate;\n    uint dripStart_ = dripStart;\n    uint dripped_ = dripped;\n    address target_ = target;\n    uint blockNumber_ = block.number;\n\n    // Next, calculate intermediate values\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\n    uint drippedNext_ = add(dripped_, toDrip_, \"tautological\");\n\n    // Finally, write new `dripped` value and transfer tokens to target\n    dripped = drippedNext_;\n    token_.safeTransfer(target_, toDrip_);\n\n    return toDrip_;\n  }\n\n  /* Internal helper functions for safe math */\n\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    uint c = a - b;\n    return c;\n  }\n\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    if (a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function min(uint a, uint b) internal pure returns (uint) {\n    if (a <= b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/distribution/RewardsDistributionRecipient.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract RewardsDistributionRecipient {\n  address public immutable rewardsDistribution;\n\n  function notifyRewardAmount(uint256 reward) external virtual;\n\n  constructor(address rewardsDistribution_) public {\n    rewardsDistribution = rewardsDistribution_;\n  }\n\n  modifier onlyRewardsDistribution() {\n    require(\n      msg.sender == rewardsDistribution,\n      \"Caller is not RewardsDistribution contract\"\n    );\n    _;\n  }\n}\n"
    },
    "contracts/distribution/StakingRewards.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/* ==========  External Libraries  ========== */\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/* ==========  External Inheritance  ========== */\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/* ==========  Internal Inheritance  ========== */\nimport \"./RewardsDistributionRecipient.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\n\n\ncontract StakingRewards is\n  IStakingRewards,\n  RewardsDistributionRecipient,\n  ReentrancyGuard\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n/* ==========  Constants  ========== */\n\n  uint256 public constant rewardsDuration = 60 days;\n\n/* ==========  Immutables  ========== */\n\n  IERC20 public immutable rewardsToken;\n\n/* ========== Events ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 amount);\n  event Withdrawn(address indexed user, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n\n/* ========== Modifiers ========== */\n\n  modifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n  }\n\n/* ==========  State Variables  ========== */\n\n  IERC20 public stakingToken;\n  uint256 public periodFinish = 0;\n  uint256 public rewardRate = 0;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n\n  uint256 private _totalSupply;\n  mapping(address => uint256) private _balances;\n\n/* ==========  Constructor  ========== */\n\n  constructor(\n    address rewardsDistribution_,\n    address rewardsToken_\n  ) public RewardsDistributionRecipient(rewardsDistribution_) {\n    rewardsToken = IERC20(rewardsToken_);\n  }\n\n  function initialize(address stakingToken_) external override {\n    require(address(stakingToken) == address(0), \"Already initialized\");\n    require(address(stakingToken_) != address(0), \"Can not set null staking token\");\n    stakingToken = IERC20(stakingToken_);\n  }\n\n/* ==========  Mutative Functions  ========== */\n\n  function stake(uint256 amount)\n    external\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"Cannot stake 0\");\n    _totalSupply = _totalSupply.add(amount);\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n    stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    emit Staked(msg.sender, amount);\n  }\n\n  function withdraw(uint256 amount)\n    public\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"Cannot withdraw 0\");\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    stakingToken.safeTransfer(msg.sender, amount);\n    emit Withdrawn(msg.sender, amount);\n  }\n\n  function getReward()\n    public\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    uint256 reward = rewards[msg.sender];\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      rewardsToken.safeTransfer(msg.sender, reward);\n      emit RewardPaid(msg.sender, reward);\n    }\n  }\n\n  function exit() external override {\n    withdraw(_balances[msg.sender]);\n    getReward();\n  }\n\n/* ========== Restricted Functions ========== */\n\n  function notifyRewardAmount(uint256 reward)\n    external\n    override(IStakingRewards, RewardsDistributionRecipient)\n    onlyRewardsDistribution\n    updateReward(address(0))\n  {\n    if (block.timestamp >= periodFinish) {\n      rewardRate = reward.div(rewardsDuration);\n    } else {\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftover = remaining.mul(rewardRate);\n      rewardRate = reward.add(leftover).div(rewardsDuration);\n    }\n\n    // Ensure the provided reward amount is not more than the balance in the contract.\n    // This keeps the reward rate in the right range, preventing overflows due to\n    // very high values of rewardRate in the earned and rewardsPerToken functions;\n    // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n    uint256 balance = rewardsToken.balanceOf(address(this));\n    require(\n      rewardRate <= balance.div(rewardsDuration),\n      \"Provided reward too high\"\n    );\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp.add(rewardsDuration);\n    emit RewardAdded(reward);\n  }\n\n/* ==========  Views  ========== */\n\n  function totalSupply() external override view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external override view returns (uint256) {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable() public override view returns (uint256) {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  function rewardPerToken() public override view returns (uint256) {\n    if (_totalSupply == 0) {\n      return rewardPerTokenStored;\n    }\n    return\n      rewardPerTokenStored.add(\n        lastTimeRewardApplicable()\n          .sub(lastUpdateTime)\n          .mul(rewardRate)\n          .mul(1e18)\n          .div(_totalSupply)\n      );\n  }\n\n  function earned(address account) public override view returns (uint256) {\n    return _balances[account]\n      .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n      .div(1e18)\n      .add(rewards[account]);\n  }\n\n  function getRewardForDuration() external override view returns (uint256) {\n    return rewardRate.mul(rewardsDuration);\n  }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface IStakingRewards {\n  // Views\n  function lastTimeRewardApplicable() external view returns (uint256);\n\n  function rewardPerToken() external view returns (uint256);\n\n  function earned(address account) external view returns (uint256);\n\n  function getRewardForDuration() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  // Mutative\n  function initialize(address stakingToken) external;\n\n  function stake(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n\n  function getReward() external;\n\n  function exit() external;\n\n  function notifyRewardAmount(uint256 reward) external;\n}\n"
    },
    "contracts/distribution/StakingRewardsFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/* ==========  External Interfaces  ========== */\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ==========  External Libraries  ========== */\nimport \"@indexed-finance/proxies/contracts/SaltyLib.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/* ==========  External Inheritance  ========== */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/* ==========  Internal Interfaces  ========== */\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\n\n/* ==========  Internal Libraries  ========== */\nimport \"../lib/UniswapV2AddressLibrary.sol\";\n\n/* ==========  Internal Inheritance  ========== */\nimport \"../interfaces/IStakingRewardsFactory.sol\";\n\n\ncontract StakingRewardsFactory is Ownable, IStakingRewardsFactory {\n  using SafeMath for uint256;\n\n/* ==========  Constants  ========== */\n\n  /**\n   * @dev Used to identify the implementation for staking rewards proxies.\n   */\n  bytes32 public override constant STAKING_REWARDS_IMPLEMENTATION_ID = keccak256(\n    \"StakingRewards.sol\"\n  );\n\n/* ==========  Immutables  ========== */\n\n  /**\n   * @dev Address of the pool factory - used to verify staking token eligibility.\n   */\n  IPoolFactory public override immutable poolFactory;\n\n  /**\n   * @dev The address of the proxy manager - used to deploy staking pools.\n   */\n  IDelegateCallProxyManager public override immutable proxyManager;\n\n  /**\n   * @dev The address of the token to distribute.\n   */\n  address public override immutable rewardsToken;\n\n  /**\n   * @dev The address of the Uniswap factory - used to compute the addresses\n   * of Uniswap pairs eligible for distribution.\n   */\n  address public override immutable uniswapFactory;\n\n  /**\n   * @dev The address of the wrapped ether token - used to identify\n   * Uniswap pairs eligible for distribution.\n   */\n  address public override immutable weth;\n\n  /**\n   * @dev Timestamp at which staking begins.\n   */\n  uint256 public override immutable stakingRewardsGenesis;\n\n/* ==========  Events  ========== */\n\n  event UniswapStakingRewardsAdded(\n    address indexPool,\n    address stakingToken,\n    address stakingRewards\n  );\n\n  event IndexPoolStakingRewardsAdded(\n    address stakingToken,\n    address stakingRewards\n  );\n\n/* ==========  Structs  ========== */\n\n  enum StakingTokenType { NDX_POOL, NDX_POOL_UNISWAP_PAIR }\n\n  struct StakingRewardsInfo {\n    StakingTokenType tokenType;\n    address stakingRewards;\n    uint88 rewardAmount;\n  }\n\n/* ==========  Storage  ========== */\n\n  /**\n   * @dev The staking tokens for which a rewards contract has been deployed.\n   */\n  address[] public override stakingTokens;\n\n  /**\n   * @dev Rewards info by staking token.\n   */\n  mapping(address => StakingRewardsInfo) public stakingRewardsInfoByStakingToken;\n\n/* ==========  Constructor  ========== */\n\n  constructor(\n    address rewardsToken_,\n    uint256 stakingRewardsGenesis_,\n    address proxyManager_,\n    address poolFactory_,\n    address uniswapFactory_,\n    address weth_\n  ) public Ownable() {\n    rewardsToken = rewardsToken_;\n    require(\n      stakingRewardsGenesis_ >= block.timestamp,\n      \"StakingRewardsFactory::constructor: genesis too soon\"\n    );\n    stakingRewardsGenesis = stakingRewardsGenesis_;\n    proxyManager = IDelegateCallProxyManager(proxyManager_);\n    poolFactory = IPoolFactory(poolFactory_);\n    uniswapFactory = uniswapFactory_;\n    weth = weth_;\n  }\n\n/* ==========  Pool Deployment  ==========  */\n  // Pool deployment functions are permissioned.\n\n  /**\n   * @dev Deploys a staking pool for the LP token of an index pool.\n   *\n   * Verifies that the staking token is the address of a pool deployed by the\n   * Indexed pool factory.\n   */\n  function deployStakingRewardsForPool(address indexPool, uint88 rewardAmount)\n    external\n    override\n    onlyOwner\n    returns (address)\n  {\n\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[indexPool];\n    require(\n      info.stakingRewards == address(0),\n      \"StakingRewardsFactory::deployStakingRewardsForPool: Already deployed\"\n    );\n    require(\n      poolFactory.isRecognizedPool(indexPool),\n      \"StakingRewardsFactory::deployStakingRewardsForPool: Not an index pool.\"\n    );\n    bytes32 stakingRewardsSalt = keccak256(abi.encodePacked(indexPool));\n    address stakingRewards = proxyManager.deployProxyManyToOne(\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      stakingRewardsSalt\n    );\n    IStakingRewards(stakingRewards).initialize(indexPool);\n    info.stakingRewards = stakingRewards;\n    info.rewardAmount = rewardAmount;\n    info.tokenType = StakingTokenType.NDX_POOL;\n    stakingTokens.push(indexPool);\n    emit IndexPoolStakingRewardsAdded(indexPool, stakingRewards);\n    return stakingRewards;\n  }\n\n  /**\n   * @dev Deploys staking rewards for the LP token of the Uniswap pair between an\n   * index pool token and WETH.\n   *\n   * Verifies that the LP token is the address of a pool deployed by the\n   * Indexed pool factory, then uses the address of the Uniswap pair between\n   * it and WETH as the staking token.\n   */\n  function deployStakingRewardsForPoolUniswapPair(\n    address indexPool,\n    uint88 rewardAmount\n  )\n    external\n    override\n    onlyOwner\n  {\n    require(\n      poolFactory.isRecognizedPool(indexPool),\n      \"StakingRewardsFactory::deployStakingRewardsForPoolUniswapPair: Not an index pool.\"\n    );\n\n    address pairAddress = UniswapV2AddressLibrary.pairFor(\n      address(uniswapFactory),\n      indexPool,\n      weth\n    );\n\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[pairAddress];\n    require(\n      info.stakingRewards == address(0),\n      \"StakingRewardsFactory::deployStakingRewardsForPoolUniswapPair: Already deployed\"\n    );\n\n    bytes32 stakingRewardsSalt = keccak256(abi.encodePacked(pairAddress));\n    address stakingRewards = proxyManager.deployProxyManyToOne(\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      stakingRewardsSalt\n    );\n\n    IStakingRewards(stakingRewards).initialize(pairAddress);\n    info.stakingRewards = stakingRewards;\n    info.rewardAmount = rewardAmount;\n    info.tokenType = StakingTokenType.NDX_POOL_UNISWAP_PAIR;\n    stakingTokens.push(pairAddress);\n    emit UniswapStakingRewardsAdded(indexPool, pairAddress, stakingRewards);\n  }\n\n/* ==========  Rewards Distribution  ========== */\n\n  function notifyRewardAmounts() public override {\n    require(\n      stakingTokens.length > 0,\n      \"StakingRewardsFactory::notifyRewardAmounts: called before any deploys\"\n    );\n    for (uint i = 0; i < stakingTokens.length; i++) {\n      notifyRewardAmount(stakingTokens[i]);\n    }\n  }\n\n  function notifyRewardAmount(address stakingToken) public override {\n    require(\n      block.timestamp >= stakingRewardsGenesis,\n      \"StakingRewardsFactory::notifyRewardAmount: Not ready\"\n    );\n\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];\n    require(\n      info.stakingRewards != address(0),\n      \"StakingRewardsFactory::notifyRewardAmount: Not deployed\"\n    );\n\n    if (info.rewardAmount > 0) {\n      uint256 rewardAmount = info.rewardAmount;\n      info.rewardAmount = 0;\n\n      require(\n        IERC20(rewardsToken).transfer(info.stakingRewards, rewardAmount),\n        \"StakingRewardsFactory::notifyRewardAmount: Transfer failed\"\n      );\n      IStakingRewards(info.stakingRewards).notifyRewardAmount(rewardAmount);\n    }\n  }\n\n/* ==========  Queries  ========== */\n\n  function getStakingTokens() external override view returns (address[] memory) {\n    return stakingTokens;\n  }\n\n  function getStakingRewards(address stakingToken) external override view returns (address) {\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];\n    require(\n      info.stakingRewards != address(0),\n      \"StakingRewardsFactory::getStakingRewards: Not deployed\"\n    );\n\n    return info.stakingRewards;\n  }\n\n  function computeStakingRewardsAddress(address stakingToken) external override view returns (address) {\n    bytes32 stakingRewardsSalt = keccak256(abi.encodePacked(stakingToken));\n    return SaltyLib.computeProxyAddressManyToOne(\n      address(proxyManager),\n      address(this),\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      stakingRewardsSalt\n    );\n  }\n}"
    },
    "@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\n *\n * An implementation identifier can be created on the proxy manager which is\n * used to specify the logic address for a particular contract type, and to\n * upgrade the implementation as needed.\n *\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\n * address.\n *\n * A many-to-one proxy is a single upgradeable implementation address that may be\n * used by many proxy contracts.\n */\ninterface IDelegateCallProxyManager {\n/* ==========  Events  ========== */\n\n  event DeploymentApprovalGranted(address deployer);\n  event DeploymentApprovalRevoked(address deployer);\n\n  event ManyToOne_ImplementationCreated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ImplementationUpdated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ProxyDeployed(\n    bytes32 implementationID,\n    address proxyAddress\n  );\n\n  event OneToOne_ProxyDeployed(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n  event OneToOne_ImplementationUpdated(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n/* ==========  Controls  ========== */\n\n  /**\n   * @dev Allows `deployer` to deploy many-to-one proxies.\n   */\n  function approveDeployer(address deployer) external;\n\n  /**\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\n   */\n  function revokeDeployerApproval(address deployer) external;\n\n/* ==========  Implementation Management  ========== */\n\n  /**\n   * @dev Creates a many-to-one proxy relationship.\n   *\n   * Deploys an implementation holder contract which stores the\n   * implementation address for many proxies. The implementation\n   * address can be updated on the holder to change the runtime\n   * code used by all its proxies.\n   *\n   * @param implementationID ID for the implementation, used to identify the\n   * proxies that use it. Also used as the salt in the create2 call when\n   * deploying the implementation holder contract.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function createManyToOneProxyRelationship(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\n   */\n  function lockImplementationManyToOne(bytes32 implementationID) external;\n\n  /**\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\n   */\n  function lockImplementationOneToOne(address proxyAddress) external;\n\n  /**\n   * @dev Updates the implementation address for a many-to-one\n   * proxy relationship.\n   *\n   * @param implementationID Identifier for the implementation.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function setImplementationAddressManyToOne(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a one-to-one proxy.\n   *\n   * Note: This could work for many-to-one as well if the caller\n   * provides the implementation holder address in place of the\n   * proxy address, as they use the same access control and update\n   * mechanism.\n   *\n   * @param proxyAddress Address of the deployed proxy\n   * @param implementation Address with the runtime code for\n   * the proxy to use.\n   */\n  function setImplementationAddressOneToOne(\n    address proxyAddress,\n    address implementation\n  ) external;\n\n/* ==========  Proxy Deployment  ========== */\n\n  /**\n   * @dev Deploy a proxy contract with a one-to-one relationship\n   * with its implementation.\n   *\n   * The proxy will have its own implementation address which can\n   * be updated by the proxy manager.\n   *\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy should use.\n   */\n  function deployProxyOneToOne(\n    bytes32 suppliedSalt,\n    address implementation\n  ) external returns(address proxyAddress);\n\n  /**\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\n   *\n   * The proxy will call the implementation holder for every transaction to\n   * determine the address to use in calls.\n   *\n   * @param implementationID Identifier for the proxy's implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deployProxyManyToOne(\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external returns(address proxyAddress);\n\n/* ==========  Queries  ========== */\n\n  /**\n   * @dev Returns a boolean stating whether `implementationID` is locked.\n   */\n  function isImplementationLocked(bytes32 implementationID) external view returns (bool);\n\n  /**\n   * @dev Returns a boolean stating whether `proxyAddress` is locked.\n   */\n  function isImplementationLocked(address proxyAddress) external view returns (bool);\n\n  /**\n   * @dev Returns a boolean stating whether `deployer` is allowed to deploy many-to-one\n   * proxies.\n   */\n  function isApprovedDeployer(address deployer) external view returns (bool);\n\n  /**\n   * @dev Queries the temporary storage value `_implementationHolder`.\n   * This is used in the constructor of the many-to-one proxy contract\n   * so that the create2 address is static (adding constructor arguments\n   * would change the codehash) and the implementation holder can be\n   * stored as a constant.\n   */\n  function getImplementationHolder() external view returns (address);\n\n  /**\n   * @dev Returns the address of the implementation holder contract\n   * for `implementationID`.\n   */\n  function getImplementationHolder(bytes32 implementationID) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy requested\n   * by `originator` using `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address originator,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(bytes32 implementationID) external view returns (address);\n}"
    },
    "@indexed-finance/proxies/contracts/SaltyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ---  External Libraries  --- */\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\n/* ---  Proxy Contracts  --- */\nimport { CodeHashes } from \"./CodeHashes.sol\";\n\n\n/**\n * @dev Library for computing create2 salts and addresses for proxies\n * deployed by `DelegateCallProxyManager`.\n *\n * Because the proxy factory is meant to be used by multiple contracts,\n * we use a salt derivation pattern that includes the address of the\n * contract that requested the proxy deployment, a salt provided by that\n * contract and the implementation ID used (for many-to-one proxies only).\n */\nlibrary SaltyLib {\n/* ---  Salt Derivation  --- */\n\n  /**\n   * @dev Derives the create2 salt for a many-to-one proxy.\n   *\n   * Many different contracts in the Indexed framework may use the\n   * same implementation contract, and they all use the same init\n   * code, so we derive the actual create2 salt from a combination\n   * of the implementation ID, the address of the account requesting\n   * deployment and the user-supplied salt.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveManyToOneSalt(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        originator,\n        implementationID,\n        suppliedSalt\n      )\n    );\n  }\n\n  /**\n   * @dev Derives the create2 salt for a one-to-one proxy.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveOneToOneSalt(\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(originator, suppliedSalt));\n  }\n\n/* ---  Address Derivation  --- */\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy deployed\n   * by `deployer` (the factory) when requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address deployer,\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveOneToOneSalt(originator, suppliedSalt);\n    return Create2.computeAddress(salt, CodeHashes.ONE_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` deployed by `deployer` (the factory)\n   * when requested by `originator` using `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address deployer,\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveManyToOneSalt(\n      originator,\n      implementationID,\n      suppliedSalt\n    );\n    return Create2.computeAddress(salt, CodeHashes.MANY_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(\n    address deployer,\n    bytes32 implementationID\n  )\n    internal\n    pure\n    returns (address)\n  {\n    return Create2.computeAddress(\n      implementationID,\n      CodeHashes.IMPLEMENTATION_HOLDER_CODEHASH,\n      deployer\n    );\n  }\n}"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"
    },
    "@indexed-finance/proxies/contracts/CodeHashes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Because we use the code hashes of the proxy contracts for proxy address\n * derivation, it is important that other packages have access to the correct\n * values when they import the salt library.\n */\nlibrary CodeHashes {\n  bytes32 internal constant ONE_TO_ONE_CODEHASH = 0xdf533b6e999d326280ce88ca39ea2eddf95ed96f6c153ed5642d9b0a95dba4a2;\n  bytes32 internal constant MANY_TO_ONE_CODEHASH = 0x8fb4522edc5e0645a7ae5cfdbfe3b34d4a14de9e0279b74da795856b5ef4f1e6;\n  bytes32 internal constant IMPLEMENTATION_HOLDER_CODEHASH = 0xfc7aed17e5c5d36a15e443235cb9c59bae4a013202cde6ab3e657fa1176d7f3e;\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IPoolFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface IPoolFactory {\n  function isRecognizedPool(address pool) external view returns (bool);\n}"
    },
    "contracts/lib/UniswapV2AddressLibrary.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nlibrary UniswapV2AddressLibrary {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n}\n"
    },
    "contracts/interfaces/IStakingRewardsFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/* ---  External Interfaces  --- */\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ---  Internal Interfaces  --- */\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\n\n\ninterface IStakingRewardsFactory {\n/* ==========  Constants  ========== */\n\n  function STAKING_REWARDS_IMPLEMENTATION_ID() external pure returns (bytes32);\n\n/* ==========  Immutables  ========== */\n\n  function poolFactory() external view returns (IPoolFactory);\n\n  function proxyManager() external view returns (IDelegateCallProxyManager);\n\n  function rewardsToken() external view returns (address);\n\n  function uniswapFactory() external view returns (address);\n\n  function weth() external view returns (address);\n\n  function stakingRewardsGenesis() external view returns (uint256);\n\n/* ==========  Storage  ========== */\n\n  function stakingTokens(uint256) external view returns (address);\n\n  /* ==========  Pool Deployment  ==========  */\n  // Pool deployment functions are permissioned.\n\n  function deployStakingRewardsForPool(address indexPool, uint88 rewardAmount) external returns (address);\n\n  function deployStakingRewardsForPoolUniswapPair(address indexPool, uint88 rewardAmount) external;\n\n/* ==========  Rewards  ========== */\n\n  function notifyRewardAmounts() external;\n\n  function notifyRewardAmount(address stakingToken) external;\n\n/* ==========  Queries  ========== */\n\n  function getStakingTokens() external view returns (address[] memory);\n\n  function getStakingRewards(address stakingToken) external view returns (address);\n\n  function computeStakingRewardsAddress(address stakingToken) external view returns (address);\n}"
    },
    "contracts/distribution/TreasuryVester.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract TreasuryVester {\n  using SafeMath for uint256;\n\n  address public ndx;\n  address public recipient;\n\n  uint256 public vestingAmount;\n  uint256 public vestingBegin;\n  uint256 public vestingCliff;\n  uint256 public vestingEnd;\n\n  uint256 public lastUpdate;\n\n  constructor(\n    address ndx_,\n    address recipient_,\n    uint256 vestingAmount_,\n    uint256 vestingBegin_,\n    uint256 vestingCliff_,\n    uint256 vestingEnd_\n  ) public {\n    require(\n      vestingBegin_ >= block.timestamp,\n      \"TreasuryVester::constructor: vesting begin too early\"\n    );\n    require(\n      vestingCliff_ >= vestingBegin_,\n      \"TreasuryVester::constructor: cliff is too early\"\n    );\n    require(\n      vestingEnd_ > vestingCliff_,\n      \"TreasuryVester::constructor: end is too early\"\n    );\n\n    ndx = ndx_;\n    recipient = recipient_;\n\n    vestingAmount = vestingAmount_;\n    vestingBegin = vestingBegin_;\n    vestingCliff = vestingCliff_;\n    vestingEnd = vestingEnd_;\n\n    lastUpdate = vestingBegin;\n  }\n\n  function setRecipient(address recipient_) public {\n    require(\n      msg.sender == recipient,\n      \"TreasuryVester::setRecipient: unauthorized\"\n    );\n    recipient = recipient_;\n  }\n\n  function claim() public {\n    require(\n      block.timestamp >= vestingCliff,\n      \"TreasuryVester::claim: not time yet\"\n    );\n    uint256 amount;\n    if (block.timestamp >= vestingEnd) {\n      amount = INdx(ndx).balanceOf(address(this));\n    } else {\n      amount = vestingAmount.mul(block.timestamp - lastUpdate).div(\n        vestingEnd - vestingBegin\n      );\n      lastUpdate = block.timestamp;\n    }\n    INdx(ndx).transfer(recipient, amount);\n  }\n}\n\ninterface INdx {\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address dst, uint256 rawAmount) external returns (bool);\n}\n"
    },
    "contracts/governance/GovernorAlpha.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/ITimelock.sol\";\n\n\ncontract GovernorAlpha {\n  /// @notice The name of this contract\n  string public constant name = \"Indexed Governor Alpha\";\n\n  /**\n   * @dev The number of votes in support of a proposal required in order for a\n   * quorum to be reached and for a vote to succeed\n   */ \n  function quorumVotes() public pure returns (uint256) {\n    return 400_000e18; // 4% of NDX\n  }\n\n  /**\n   * @dev The number of votes required in order for a voter to become a proposer\n   */\n  function proposalThreshold() public pure returns (uint256) {\n    return 100_000e18; // 1% of NDX\n  }\n\n  /**\n   * @dev The maximum number of actions that can be included in a proposal\n   */\n  function proposalMaxOperations() public pure returns (uint256) {\n    return 10;\n  }\n\n  /**\n   * @dev The delay before voting on a proposal may take place, once proposed\n   */\n  function votingDelay() public pure returns (uint256) {\n    return 1;\n  }\n\n  /**\n   * @dev The duration of voting on a proposal, in blocks\n   */\n  function votingPeriod() public pure returns (uint256) {\n    return 40_320; // ~7 days in blocks (assuming 15s blocks)\n  }\n\n  /**\n   * @dev The address of the Indexed Protocol Timelock\n   */\n  ITimelock public timelock;\n\n  /**\n   * @dev The address of the Indexed governance token\n   */\n  NdxInterface public ndx;\n\n  /**\n   * @dev The total number of proposals\n   */\n  uint256 public proposalCount;\n\n  /**\n   * @param id Unique id for looking up a proposal\n   * @param proposer Creator of the proposal\n   * @param eta The timestamp that the proposal will be available for execution, set once the vote succeeds\n   * @param targets The ordered list of target addresses for calls to be made\n   * @param values The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n   * @param signatures The ordered list of function signatures to be called\n   * @param calldatas The ordered list of calldata to be passed to each call\n   * @param startBlock The block at which voting begins: holders must delegate their votes prior to this block\n   * @param endBlock The block at which voting ends: votes must be cast prior to this block\n   * @param forVotes Current number of votes in favor of this proposal\n   * @param againstVotes Current number of votes in opposition to this proposal\n   * @param canceled Flag marking whether the proposal has been canceled\n   * @param executed Flag marking whether the proposal has been executed\n   * @param receipts Receipts of ballots for the entire set of voters\n   */\n  struct Proposal {\n    uint256 id;\n    address proposer;\n    uint256 eta;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    bool canceled;\n    bool executed;\n    mapping(address => Receipt) receipts;\n  }\n\n  /**\n   * @dev Ballot receipt record for a voter\n   * @param hasVoted Whether or not a vote has been cast\n   * @param support Whether or not the voter supports the proposal\n   * @param votes The number of votes the voter had, which were cast\n   */\n  struct Receipt {\n    bool hasVoted;\n    bool support;\n    uint96 votes;\n  }\n\n  /**\n   * @dev Possible states that a proposal may be in\n   */\n  enum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n  }\n\n  /**\n   * @dev The official record of all proposals ever proposed\n   */\n  mapping(uint256 => Proposal) public proposals;\n\n  /**\n   * @dev The latest proposal for each proposer\n   */\n  mapping(address => uint256) public latestProposalIds;\n\n  /**\n   * @dev The EIP-712 typehash for the contract's domain\n   */\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n    \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n  );\n\n  /**\n   * @dev The EIP-712 typehash for the ballot struct used by the contract\n   */\n  bytes32 public constant BALLOT_TYPEHASH = keccak256(\n    \"Ballot(uint256 proposalId,bool support)\"\n  );\n\n  /**\n   * @dev An event emitted when a new proposal is created\n   */\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startBlock,\n    uint256 endBlock,\n    string description\n  );\n\n  /**\n   * @dev An event emitted when a vote has been cast on a proposal\n   */\n  event VoteCast(\n    address voter,\n    uint256 proposalId,\n    bool support,\n    uint256 votes\n  );\n\n  /**\n   * @dev An event emitted when a proposal has been canceled\n   */\n  event ProposalCanceled(uint256 id);\n\n  /**\n   * @dev An event emitted when a proposal has been queued in the Timelock\n   */\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  /**\n   * @dev An event emitted when a proposal has been executed in the Timelock\n   */\n  event ProposalExecuted(uint256 id);\n\n  constructor(address timelock_, address ndx_) public {\n    timelock = ITimelock(timelock_);\n    ndx = NdxInterface(ndx_);\n  }\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n  ) public returns (uint256) {\n    require(\n      ndx.getPriorVotes(msg.sender, sub256(block.number, 1)) >\n        proposalThreshold(),\n      \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n    );\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(\n      targets.length != 0,\n      \"GovernorAlpha::propose: must provide actions\"\n    );\n    require(\n      targets.length <= proposalMaxOperations(),\n      \"GovernorAlpha::propose: too many actions\"\n    );\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n      );\n      require(\n        proposersLatestProposalState != ProposalState.Pending,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n      );\n    }\n\n    uint256 startBlock = add256(block.number, votingDelay());\n    uint256 endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    Proposal memory newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: targets,\n      values: values,\n      signatures: signatures,\n      calldatas: calldatas,\n      startBlock: startBlock,\n      endBlock: endBlock,\n      forVotes: 0,\n      againstVotes: 0,\n      canceled: false,\n      executed: false\n    });\n\n    proposals[newProposal.id] = newProposal;\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      startBlock,\n      endBlock,\n      description\n    );\n    return newProposal.id;\n  }\n\n  function queue(uint256 proposalId) public {\n    require(\n      state(proposalId) == ProposalState.Succeeded,\n      \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    uint256 eta = add256(block.timestamp, timelock.delay());\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        eta\n      );\n    }\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n  }\n\n  function _queueOrRevert(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) internal {\n    require(\n      !timelock.queuedTransactions(\n        keccak256(abi.encode(target, value, signature, data, eta))\n      ),\n      \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n    );\n    timelock.queueTransaction(target, value, signature, data, eta);\n  }\n\n  function execute(uint256 proposalId) public payable {\n    require(\n      state(proposalId) == ProposalState.Queued,\n      \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.executeTransaction.value(proposal.values[i])(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n    emit ProposalExecuted(proposalId);\n  }\n\n  function cancel(uint256 proposalId) public {\n    ProposalState state = state(proposalId);\n    require(\n      state != ProposalState.Executed,\n      \"GovernorAlpha::cancel: cannot cancel executed proposal\"\n    );\n\n    Proposal storage proposal = proposals[proposalId];\n    require(\n      ndx.getPriorVotes(proposal.proposer, sub256(block.number, 1)) <\n        proposalThreshold(),\n      \"GovernorAlpha::cancel: proposer above threshold\"\n    );\n\n    proposal.canceled = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.cancelTransaction(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  function getActions(uint256 proposalId)\n    public\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    )\n  {\n    Proposal storage p = proposals[proposalId];\n    return (p.targets, p.values, p.signatures, p.calldatas);\n  }\n\n  function getReceipt(uint256 proposalId, address voter)\n    public\n    view\n    returns (Receipt memory)\n  {\n    return proposals[proposalId].receipts[voter];\n  }\n\n  function state(uint256 proposalId) public view returns (ProposalState) {\n    require(\n      proposalCount >= proposalId && proposalId > 0,\n      \"GovernorAlpha::state: invalid proposal id\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n      return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n      return ProposalState.Active;\n    } else if (\n      proposal.forVotes <= proposal.againstVotes ||\n      proposal.forVotes < quorumVotes()\n    ) {\n      return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (\n      block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())\n    ) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function castVote(uint256 proposalId, bool support) public {\n    return _castVote(msg.sender, proposalId, support);\n  }\n\n  function castVoteBySig(\n    uint256 proposalId,\n    bool support,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(BALLOT_TYPEHASH, proposalId, support)\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(\n      signatory != address(0),\n      \"GovernorAlpha::castVoteBySig: invalid signature\"\n    );\n    return _castVote(signatory, proposalId, support);\n  }\n\n  function _castVote(\n    address voter,\n    uint256 proposalId,\n    bool support\n  ) internal {\n    require(\n      state(proposalId) == ProposalState.Active,\n      \"GovernorAlpha::_castVote: voting is closed\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(\n      receipt.hasVoted == false,\n      \"GovernorAlpha::_castVote: voter already voted\"\n    );\n    uint96 votes = ndx.getPriorVotes(voter, proposal.startBlock);\n\n    if (support) {\n      proposal.forVotes = add256(proposal.forVotes, votes);\n    } else {\n      proposal.againstVotes = add256(proposal.againstVotes, votes);\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n  }\n\n  function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"addition overflow\");\n    return c;\n  }\n\n  function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"subtraction underflow\");\n    return a - b;\n  }\n\n  function getChainId() internal pure returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n\ninterface NdxInterface {\n  function getPriorVotes(address account, uint256 blockNumber)\n    external\n    view\n    returns (uint96);\n}\n"
    },
    "contracts/interfaces/ITimelock.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface ITimelock {\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  function GRACE_PERIOD() external pure returns (uint256);\n  \n  function MINIMUM_DELAY() external pure returns (uint256);\n  \n  function MAXIMUM_DELAY() external pure returns (uint256);\n\n  function admin() external view returns (address);\n\n  function pendingAdmin() external view returns (address);\n\n  function delay() external view returns (uint256);\n\n  function queuedTransactions(bytes32) external view returns (bool);\n\n  function setDelay(uint256 delay_) external;\n\n  function acceptAdmin() external;\n\n  function setPendingAdmin(address pendingAdmin_) external;\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/governance/Ndx.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Ndx {\n  /// @notice EIP-20 token name for this token\n  string public constant name = \"Indexed\";\n\n  /// @notice EIP-20 token symbol for this token\n  string public constant symbol = \"NDX\";\n\n  /// @notice EIP-20 token decimals for this token\n  uint8 public constant decimals = 18;\n\n  /// @notice Total number of tokens in circulation\n  uint256 public constant totalSupply = 10_000_000e18;\n\n  mapping(address => mapping(address => uint96)) internal allowances;\n\n  mapping(address => uint96) internal balances;\n\n  mapping(address => address) public delegates;\n\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n\n  mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n  mapping(address => uint32) public numCheckpoints;\n\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n    \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n  );\n\n  bytes32 public constant DELEGATION_TYPEHASH = keccak256(\n    \"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"\n  );\n\n  bytes32 public constant PERMIT_TYPEHASH = keccak256(\n    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n  );\n\n  mapping(address => uint256) public nonces;\n\n  event DelegateChanged(\n    address indexed delegator,\n    address indexed fromDelegate,\n    address indexed toDelegate\n  );\n\n  event DelegateVotesChanged(\n    address indexed delegate,\n    uint256 previousBalance,\n    uint256 newBalance\n  );\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n\n  constructor(address account) public {\n    balances[account] = uint96(totalSupply);\n    emit Transfer(address(0), account, totalSupply);\n  }\n\n  function allowance(address account, address spender)\n    external\n    view\n    returns (uint256)\n  {\n    return allowances[account][spender];\n  }\n\n  function approve(address spender, uint256 rawAmount) external returns (bool) {\n    uint96 amount;\n    if (rawAmount == uint256(-1)) {\n      amount = uint96(-1);\n    } else {\n      amount = safe96(rawAmount, \"Ndx::approve: amount exceeds 96 bits\");\n    }\n\n    allowances[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 rawAmount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    uint96 amount;\n    if (rawAmount == uint256(-1)) {\n      amount = uint96(-1);\n    } else {\n      amount = safe96(rawAmount, \"Ndx::permit: amount exceeds 96 bits\");\n    }\n\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        rawAmount,\n        nonces[owner]++,\n        deadline\n      )\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Ndx::permit: invalid signature\");\n    require(signatory == owner, \"Ndx::permit: unauthorized\");\n    require(now <= deadline, \"Ndx::permit: signature expired\");\n\n    allowances[owner][spender] = amount;\n\n    emit Approval(owner, spender, amount);\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return balances[account];\n  }\n\n  function nonceOf(address account) external view returns (uint256) {\n    return nonces[account];\n  }\n\n  function transfer(address dst, uint256 rawAmount) external returns (bool) {\n    uint96 amount = safe96(rawAmount, \"Ndx::transfer: amount exceeds 96 bits\");\n    _transferTokens(msg.sender, dst, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 rawAmount\n  ) external returns (bool) {\n    address spender = msg.sender;\n    uint96 spenderAllowance = allowances[src][spender];\n    uint96 amount = safe96(rawAmount, \"Ndx::approve: amount exceeds 96 bits\");\n\n    if (spender != src && spenderAllowance != uint96(-1)) {\n      uint96 newAllowance = sub96(\n        spenderAllowance,\n        amount,\n        \"Ndx::transferFrom: transfer amount exceeds spender allowance\"\n      );\n      allowances[src][spender] = newAllowance;\n\n      emit Approval(src, spender, newAllowance);\n    }\n\n    _transferTokens(src, dst, amount);\n    return true;\n  }\n\n  function delegate(address delegatee) public {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Ndx::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"Ndx::delegateBySig: invalid nonce\");\n    require(now <= expiry, \"Ndx::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n  function getCurrentVotes(address account) external view returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  function getPriorVotes(address account, uint256 blockNumber)\n    public\n    view\n    returns (uint96)\n  {\n    require(\n      blockNumber < block.number,\n      \"Ndx::getPriorVotes: not yet determined\"\n    );\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n      return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint32 center = upper - (upper - lower) / 2;\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock < blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _transferTokens(\n    address src,\n    address dst,\n    uint96 amount\n  ) internal {\n    require(\n      src != address(0),\n      \"Ndx::_transferTokens: cannot transfer from the zero address\"\n    );\n    require(\n      dst != address(0),\n      \"Ndx::_transferTokens: cannot transfer to the zero address\"\n    );\n\n    balances[src] = sub96(\n      balances[src],\n      amount,\n      \"Ndx::_transferTokens: transfer amount exceeds balance\"\n    );\n    balances[dst] = add96(\n      balances[dst],\n      amount,\n      \"Ndx::_transferTokens: transfer amount overflows\"\n    );\n    emit Transfer(src, dst, amount);\n\n    _moveDelegates(delegates[src], delegates[dst], amount);\n  }\n\n  function _moveDelegates(\n    address srcRep,\n    address dstRep,\n    uint96 amount\n  ) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum > 0\n          ? checkpoints[srcRep][srcRepNum - 1].votes\n          : 0;\n        uint96 srcRepNew = sub96(\n          srcRepOld,\n          amount,\n          \"Ndx::_moveVotes: vote amount underflows\"\n        );\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum > 0\n          ? checkpoints[dstRep][dstRepNum - 1].votes\n          : 0;\n        uint96 dstRepNew = add96(\n          dstRepOld,\n          amount,\n          \"Ndx::_moveVotes: vote amount overflows\"\n        );\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    address delegatee,\n    uint32 nCheckpoints,\n    uint96 oldVotes,\n    uint96 newVotes\n  ) internal {\n    uint32 blockNumber = safe32(\n      block.number,\n      \"Ndx::_writeCheckpoint: block number exceeds 32 bits\"\n    );\n\n    if (\n      nCheckpoints > 0 &&\n      checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n    ) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint256 n, string memory errorMessage)\n    internal\n    pure\n    returns (uint32)\n  {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function safe96(uint256 n, string memory errorMessage)\n    internal\n    pure\n    returns (uint96)\n  {\n    require(n < 2**96, errorMessage);\n    return uint96(n);\n  }\n\n  function add96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function getChainId() internal pure returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n"
    },
    "contracts/governance/Timelock.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../interfaces/ITimelock.sol\";\n\n\ncontract Timelock is ITimelock {\n  using SafeMath for uint256;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  uint256 public constant override GRACE_PERIOD = 14 days;\n  uint256 public constant override MINIMUM_DELAY = 2 days;\n  uint256 public constant override MAXIMUM_DELAY = 30 days;\n\n  address public override admin;\n  address public override pendingAdmin;\n  uint256 public override delay;\n\n  mapping(bytes32 => bool) public override queuedTransactions;\n\n  constructor(address admin_, uint256 delay_) public {\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::constructor: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  fallback() external payable {}\n\n  function setDelay(uint256 delay_) public override {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setDelay: Call must come from Timelock.\"\n    );\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::setDelay: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public override {\n    require(\n      msg.sender == pendingAdmin,\n      \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n    );\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public override {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n    );\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override returns (bytes32) {\n    require(\n      msg.sender == admin,\n      \"Timelock::queueTransaction: Call must come from admin.\"\n    );\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override {\n    require(\n      msg.sender == admin,\n      \"Timelock::cancelTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable override returns (bytes memory) {\n    require(\n      msg.sender == admin,\n      \"Timelock::executeTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(\n      queuedTransactions[txHash],\n      \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockTimestamp() >= eta,\n      \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n      \"Timelock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    (bool success, bytes memory returnData) = target.call{value: value}(callData);\n    require(\n      success,\n      \"Timelock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint256) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Detailed {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/mocks/BaseERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n// Originally from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n// This source code has been modified from the original.\n// Subject to the MIT license.\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract BaseERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) internal _balances;\n\n  mapping (address => mapping (address => uint256)) internal _allowances;\n\n  uint256 internal _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n    * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n    * a default value of 18.\n    *\n    * To select a different value for {decimals}, use {_setupDecimals}.\n    *\n    * All three of these values are immutable: they can only be set once during\n    * construction.\n    */\n  constructor (string memory name, string memory symbol) public {\n    _name = name;\n    _symbol = symbol;\n    _decimals = 18;\n  }\n\n  /**\n    * @dev Returns the name of the token.\n    */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n    * @dev Returns the symbol of the token, usually a shorter version of the\n    * name.\n    */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n    * @dev Returns the number of decimals used to get its user representation.\n    * For example, if `decimals` equals `2`, a balance of `505` tokens should\n    * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n    *\n    * Tokens usually opt for a value of 18, imitating the relationship between\n    * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n    * called.\n    *\n    * NOTE: This information is only used for _display_ purposes: it in\n    * no way affects any of the arithmetic of the contract, including\n    * {IERC20-balanceOf} and {IERC20-transfer}.\n    */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n    * @dev See {IERC20-totalSupply}.\n    */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n    * @dev See {IERC20-balanceOf}.\n    */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n    * @dev See {IERC20-transfer}.\n    *\n    * Requirements:\n    *\n    * - `recipient` cannot be the zero address.\n    * - the caller must have a balance of at least `amount`.\n    */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  /**\n    * @dev See {IERC20-allowance}.\n    */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n    * @dev See {IERC20-approve}.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Emits an {Approval} event indicating the updated allowance. This is not\n    * required by the EIP. See the note at the beginning of {ERC20};\n    *\n    * Requirements:\n    * - `sender` and `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    * - the caller must have allowance for ``sender``'s tokens of at least\n    * `amount`.\n    */\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      msg.sender,\n      _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n    );\n    return true;\n  }\n\n  /**\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    * - `spender` must have allowance for the caller of at least\n    * `subtractedValue`.\n    */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n    );\n    return true;\n  }\n\n  /**\n    * @dev Moves tokens `amount` from `sender` to `recipient`.\n    *\n    * This is internal function is equivalent to {transfer}, and can be used to\n    * e.g. implement automatic token fees, slashing mechanisms, etc.\n    *\n    * Emits a {Transfer} event.\n    *\n    * Requirements:\n    *\n    * - `sender` cannot be the zero address.\n    * - `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /**\n    * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n    *\n    * This is internal function is equivalent to `approve`, and can be used to\n    * e.g. set automatic allowances for certain subsystems, etc.\n    *\n    * Emits an {Approval} event.\n    *\n    * Requirements:\n    *\n    * - `owner` cannot be the zero address.\n    * - `spender` cannot be the zero address.\n    */\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n    * @dev Sets {decimals} to a value other than the default one of 18.\n    *\n    * WARNING: This function should only be called from the constructor. Most\n    * applications that interact with token contracts will not expect\n    * {decimals} to ever change, and may work incorrectly if it does.\n    */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n    * @dev Hook that is called before any transfer of tokens. This includes\n    * minting and burning.\n    *\n    * Calling conditions:\n    *\n    * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n    * will be to transferred to `to`.\n    * - when `from` is zero, `amount` tokens will be minted for `to`.\n    * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n    * - `from` and `to` are never both zero.\n    *\n    * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n    */\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./BaseERC20.sol\";\n\n\ncontract MockERC20 is BaseERC20 {\n  constructor(\n    string memory name,\n    string memory symbol\n  ) public BaseERC20(name, symbol) {}\n\n  // Mocks WETH deposit fn\n  function deposit() external payable {\n    _mint(msg.sender, msg.value);\n  }\n\n  function getFreeTokens(address to, uint256 amount) public {\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n}"
    },
    "contracts/mocks/MockPoolFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../interfaces/IPoolFactory.sol\";\n\n\ncontract MockPoolFactory {\n  mapping(address => bool) public isRecognizedPool;\n\n  function addIPool(address poolAddress) public {\n    isRecognizedPool[poolAddress] = true;\n  }\n}"
    },
    "contracts/mocks/MockTimelock.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../interfaces/ITimelock.sol\";\n\n\n/**\n * Overrides the minimum delay\n */\ncontract MockTimelock is ITimelock {\n  using SafeMath for uint256;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  uint256 public constant override GRACE_PERIOD = 14 days;\n  uint256 public constant override MINIMUM_DELAY = 20 minutes;\n  uint256 public constant override MAXIMUM_DELAY = 30 days;\n\n  address public override admin;\n  address public override pendingAdmin;\n  uint256 public override delay;\n\n  mapping(bytes32 => bool) public override queuedTransactions;\n\n  constructor(address admin_, uint256 delay_) public {\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::constructor: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  fallback() external payable {}\n\n  function setDelay(uint256 delay_) public override {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setDelay: Call must come from Timelock.\"\n    );\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::setDelay: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public override {\n    require(\n      msg.sender == pendingAdmin,\n      \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n    );\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public override {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n    );\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override returns (bytes32) {\n    require(\n      msg.sender == admin,\n      \"Timelock::queueTransaction: Call must come from admin.\"\n    );\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override {\n    require(\n      msg.sender == admin,\n      \"Timelock::cancelTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable override returns (bytes memory) {\n    require(\n      msg.sender == admin,\n      \"Timelock::executeTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(\n      queuedTransactions[txHash],\n      \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockTimestamp() >= eta,\n      \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n      \"Timelock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{value: value}(\n      callData\n    );\n    require(\n      success,\n      \"Timelock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint256) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/mocks/ReservoirErrorTrigger.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../distribution/Reservoir.sol\";\n\ncontract ReservoirErrorTrigger is Reservoir {\n  constructor(uint dripRate_, IERC20 token_, address target_)\n    public\n    Reservoir(dripRate_, token_, target_)\n  {}\n\n  function triggerDeltaDripUnderflow() public {\n    uint dripRate_ = dripRate;\n    uint dripStart_ = dripStart;\n    uint blockNumber_ = block.number;\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"\");\n    dripped = add(dripTotal_, 1, \"\");\n    drip();\n  }\n\n  function triggerAdditionOverflow() public {\n    uint a = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0;\n    uint b = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0;\n    add(a, b, \"addition overflow\");\n  }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}
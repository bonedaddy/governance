{
  "language": "Solidity",
  "sources": {
    "contracts/distribution/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/*\nCopyright 2020 Compound Labs, Inc.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that\nthe following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the\nfollowing disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and\nthe following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or\npromote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/**\n * @title Reservoir Contract\n * @dev Distributes a token to a different contract at a fixed rate.\n * @dev This contract must be poked via the `drip()` function every so often.\n * @author Compound\n */\ncontract Reservoir {\n  using SafeERC20 for IERC20;\n\n  /**\n   * @dev The block number when the Reservoir started (immutable)\n   */\n  uint public immutable dripStart;\n\n  /**\n   * @dev Tokens per block that to drip to target (immutable)\n   */\n  uint public immutable dripRate;\n\n  /**\n   * @dev Reference to token to drip (immutable)\n   */\n  IERC20 public immutable token;\n\n  /**\n   * @dev Target to receive dripped tokens (immutable)\n   */\n  address public immutable target;\n\n  /**\n   * @dev Amount that has already been dripped\n   */\n  uint public dripped;\n\n  /**\n    * @dev Constructs a Reservoir\n    * @param dripRate_ Numer of tokens per block to drip\n    * @param token_ The token to drip\n    * @param target_ The recipient of dripped tokens\n    */\n  constructor(uint dripRate_, IERC20 token_, address target_) public {\n    dripStart = block.number;\n    dripRate = dripRate_;\n    token = token_;\n    target = target_;\n    dripped = 0;\n  }\n\n  /**\n    * @dev Drips the maximum amount of tokens to match the drip rate since inception\n    * @dev Note: this will only drip up to the amount of tokens available.\n    * @return The amount of tokens dripped in this call\n    */\n  function drip() public returns (uint) {\n    // First, read storage into memory\n    IERC20 token_ = token;\n    uint reservoirBalance_ = token_.balanceOf(address(this));\n    uint dripRate_ = dripRate;\n    uint dripStart_ = dripStart;\n    uint dripped_ = dripped;\n    address target_ = target;\n    uint blockNumber_ = block.number;\n\n    // Next, calculate intermediate values\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\n    uint drippedNext_ = add(dripped_, toDrip_, \"tautological\");\n\n    // Finally, write new `dripped` value and transfer tokens to target\n    dripped = drippedNext_;\n    token_.safeTransfer(target_, toDrip_);\n\n    return toDrip_;\n  }\n\n  /* Internal helper functions for safe math */\n\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    uint c = a - b;\n    return c;\n  }\n\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    if (a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function min(uint a, uint b) internal pure returns (uint) {\n    if (a <= b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/distribution/RewardsDistributionRecipient.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract RewardsDistributionRecipient {\n  address public immutable rewardsDistribution;\n\n  function notifyRewardAmount(uint256 reward) external virtual;\n\n  constructor(address rewardsDistribution_) public {\n    rewardsDistribution = rewardsDistribution_;\n  }\n\n  modifier onlyRewardsDistribution() {\n    require(\n      msg.sender == rewardsDistribution,\n      \"Caller is not RewardsDistribution contract\"\n    );\n    _;\n  }\n}\n"
    },
    "contracts/distribution/StakingRewards.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n// Inheritance\nimport \"../interfaces/IStakingRewards.sol\";\nimport \"./RewardsDistributionRecipient.sol\";\n\n\ncontract StakingRewards is\n  IStakingRewards,\n  RewardsDistributionRecipient,\n  ReentrancyGuard\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== IMMUTABLES ========== */\n  IERC20 public immutable rewardsToken;\n\n  /* ========== STATE VARIABLES ========== */\n\n  IERC20 public stakingToken;\n  uint256 public periodFinish = 0;\n  uint256 public rewardRate = 0;\n  uint256 public rewardsDuration = 60 days;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n\n  uint256 private _totalSupply;\n  mapping(address => uint256) private _balances;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    address rewardsDistribution_,\n    address rewardsToken_\n  ) public RewardsDistributionRecipient(rewardsDistribution_) {\n    rewardsToken = IERC20(rewardsToken_);\n  }\n\n  function initialize(address stakingToken_) external override {\n    require(address(stakingToken) == address(0), \"ERR_INITIALIZED\");\n    stakingToken = IERC20(stakingToken_);\n  }\n\n  /* ========== VIEWS ========== */\n\n  function totalSupply() external override view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external override view returns (uint256) {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable() public override view returns (uint256) {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  function rewardPerToken() public override view returns (uint256) {\n    if (_totalSupply == 0) {\n      return rewardPerTokenStored;\n    }\n    return\n      rewardPerTokenStored.add(\n        lastTimeRewardApplicable()\n          .sub(lastUpdateTime)\n          .mul(rewardRate)\n          .mul(1e18)\n          .div(_totalSupply)\n      );\n  }\n\n  function earned(address account) public override view returns (uint256) {\n    return _balances[account]\n      .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n      .div(1e18)\n      .add(rewards[account]);\n  }\n\n  function getRewardForDuration() external override view returns (uint256) {\n    return rewardRate.mul(rewardsDuration);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function stake(uint256 amount)\n    external\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"Cannot stake 0\");\n    _totalSupply = _totalSupply.add(amount);\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n    stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    emit Staked(msg.sender, amount);\n  }\n\n  function withdraw(uint256 amount)\n    public\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"Cannot withdraw 0\");\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    stakingToken.safeTransfer(msg.sender, amount);\n    emit Withdrawn(msg.sender, amount);\n  }\n\n  function getReward()\n    public\n    override\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    uint256 reward = rewards[msg.sender];\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      rewardsToken.safeTransfer(msg.sender, reward);\n      emit RewardPaid(msg.sender, reward);\n    }\n  }\n\n  function exit() external override {\n    withdraw(_balances[msg.sender]);\n    getReward();\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function notifyRewardAmount(uint256 reward)\n    external\n    override(IStakingRewards, RewardsDistributionRecipient)\n    onlyRewardsDistribution\n    updateReward(address(0))\n  {\n    if (block.timestamp >= periodFinish) {\n      rewardRate = reward.div(rewardsDuration);\n    } else {\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftover = remaining.mul(rewardRate);\n      rewardRate = reward.add(leftover).div(rewardsDuration);\n    }\n\n    // Ensure the provided reward amount is not more than the balance in the contract.\n    // This keeps the reward rate in the right range, preventing overflows due to\n    // very high values of rewardRate in the earned and rewardsPerToken functions;\n    // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n    uint256 balance = rewardsToken.balanceOf(address(this));\n    require(\n      rewardRate <= balance.div(rewardsDuration),\n      \"Provided reward too high\"\n    );\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp.add(rewardsDuration);\n    emit RewardAdded(reward);\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 amount);\n  event Withdrawn(address indexed user, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface IStakingRewards {\n  // Views\n  function lastTimeRewardApplicable() external view returns (uint256);\n\n  function rewardPerToken() external view returns (uint256);\n\n  function earned(address account) external view returns (uint256);\n\n  function getRewardForDuration() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  // Mutative\n  function initialize(address stakingToken) external;\n\n  function stake(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n\n  function getReward() external;\n\n  function exit() external;\n\n  function notifyRewardAmount(uint256 reward) external;\n}\n"
    },
    "contracts/distribution/StakingRewardsFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/* ---  External Interfaces  --- */\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ---  External Libraries  --- */\nimport { SaltyLib as Salty } from  \"@indexed-finance/proxies/contracts/SaltyLib.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/* ---  Internal Interfaces  --- */\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\n\n/* ---  Internal Libraries  --- */\nimport { UniswapV2AddressLibrary } from \"../lib/UniswapV2AddressLibrary.sol\";\n\n/* ---  Inheritance  --- */\nimport \"../lib/Owned.sol\";\n\n\ncontract StakingRewardsFactory is Owned {\n  using SafeMath for uint;\n\n/* ---  Constants  --- */\n  bytes32 public constant STAKING_REWARDS_IMPLEMENTATION_ID = keccak256(\"StakingRewards.sol\");\n  uint256 internal constant POINTS_MULTIPLIER = 10**18;\n\n/* ---  Immutables  --- */\n  IPoolFactory public immutable poolFactory;\n  IDelegateCallProxyManager public immutable proxyManager;\n  address public immutable rewardsToken;\n  address public immutable uniswapFactory;\n  address public immutable weth;\n  uint256 public immutable stakingRewardsGenesis;\n\n/* ---  Events  --- */\n  event RewardsUpdated(address stakingPool, uint256 rewardsAdded);\n\n/* ---  Structs  --- */\n  struct RewardsData {\n    uint96 totalRewards;\n    uint160 totalRewardPoints;\n  }\n\n/* ---  Storage  --- */\n\n  /**\n   * @dev The staking tokens for which the rewards contract has been deployed.\n   */\n  address[] public stakingTokens;\n\n  /**\n   * @dev Metadata about all distributions.\n   */\n  RewardsData internal _rewards;\n\n  /**\n   * @dev Total points claimed by each staking pool.\n   */\n  mapping(address => uint256) internal _lastRewardPoints;\n\n/* ---  Constructor  --- */\n  constructor(\n    address owner_,\n    address rewardsToken_,\n    uint256 stakingRewardsGenesis_,\n    address proxyManager_,\n    address poolFactory_,\n    address uniswapFactory_,\n    address weth_\n  ) public Owned(owner_) {\n    rewardsToken = rewardsToken_;\n    stakingRewardsGenesis = stakingRewardsGenesis_;\n    proxyManager = IDelegateCallProxyManager(proxyManager_);\n    poolFactory = IPoolFactory(poolFactory_);\n    uniswapFactory = uniswapFactory_;\n    weth = weth_;\n  }\n\n  function deployStakingPoolForIndex(address indexPool) external _owner_ {\n    require(poolFactory.isIPool(indexPool), \"Error: Not an index pool.\");\n    bytes32 stakingPoolSalt = keccak256(abi.encode(indexPool));\n    address stakingPool = proxyManager.deployProxyManyToOne(\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      stakingPoolSalt\n    );\n    IStakingRewards(stakingPool).initialize(indexPool);\n    stakingTokens.push(indexPool);\n    _lastRewardPoints[stakingPool] = _rewards.totalRewardPoints;\n  }\n\n  function deployStakingPoolForIndexUniswapPair(address indexPool) external _owner_ {\n    require(poolFactory.isIPool(indexPool), \"Error: Not an index pool.\");\n    address pairAddress = UniswapV2AddressLibrary.pairFor(address(poolFactory), indexPool, weth);\n    bytes32 stakingPoolSalt = keccak256(abi.encode(pairAddress));\n    address stakingPool = proxyManager.deployProxyManyToOne(\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      stakingPoolSalt\n    );\n    IStakingRewards(stakingPool).initialize(indexPool);\n    stakingTokens.push(pairAddress);\n    _lastRewardPoints[stakingPool] = _rewards.totalRewardPoints;\n  }\n\n/* ---  Reward Actions  --- */\n\n  /**\n   * @dev Updates the rewards with new tokens to distribute.\n   *\n   * Note: This assumes that the maximum total tokens distributed through the\n   * rewards contract is less than 2**96 - 1\n   */\n  function addRewards() external {\n    RewardsData memory rewards = _rewards;\n    uint256 balance = IERC20(rewardsToken).balanceOf(address(this));\n    uint256 amount = balance.sub(rewards.totalRewards);\n    require(amount > 0, \"Error: No new rewards to distribute.\");\n    rewards.totalRewards = uint96(balance);\n    uint256 newPoints = (amount * POINTS_MULTIPLIER) / stakingTokens.length;\n    rewards.totalRewardPoints = uint160(rewards.totalRewardPoints + newPoints);\n    _rewards = rewards;\n  }\n\n  function notifyRewardAmount(address stakingPool) public {\n    RewardsData memory rewards = _rewards;\n    uint256 newPoints = uint256(rewards.totalRewardPoints).sub(_lastRewardPoints[stakingPool]);\n    uint256 owed = newPoints / POINTS_MULTIPLIER;\n    _lastRewardPoints[stakingPool] = rewards.totalRewardPoints;\n    if (owed > 0) {\n      IStakingRewards(stakingPool).notifyRewardAmount(owed);\n    }\n  }\n\n/* ---  Reward Queries  --- */\n  function rewardsOwed(address stakingPool) public view returns (uint256) {\n    uint256 newPoints = uint256(_rewards.totalRewardPoints).sub(_lastRewardPoints[stakingPool]);\n    return newPoints.div(POINTS_MULTIPLIER);\n  }\n\n  function getStakingPool(address stakingToken) public view returns (address) {\n    return Salty.computeProxyAddressManyToOne(\n      address(proxyManager),\n      address(this),\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      keccak256(abi.encode(stakingToken))\n    );\n  }\n}"
    },
    "@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\n *\n * An implementation identifier can be created on the proxy manager which is\n * used to specify the logic address for a particular contract type, and to\n * upgrade the implementation as needed.\n *\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\n * address.\n *\n * A many-to-one proxy is a single upgradeable implementation address that may be\n * used by many proxy contracts.\n */\ninterface IDelegateCallProxyManager {\n/* ---  Events  --- */\n\n  event DeploymentApprovalGranted(address deployer);\n  event DeploymentApprovalRevoked(address deployer);\n\n  event ManyToOne_ImplementationCreated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ImplementationUpdated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ProxyDeployed(\n    bytes32 implementationID,\n    address proxyAddress\n  );\n\n  event OneToOne_ProxyDeployed(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n  event OneToOne_ImplementationUpdated(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n/* ---  Controls  --- */\n\n  /**\n   * @dev Allows `deployer` to deploy many-to-one proxies.\n   */\n  function approveDeployer(address deployer) external;\n\n  /**\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\n   */\n  function revokeDeployerApproval(address deployer) external;\n\n/* ---  Implementation Management  --- */\n\n  /**\n   * @dev Creates a many-to-one proxy relationship.\n   *\n   * Deploys an implementation holder contract which stores the\n   * implementation address for many proxies. The implementation\n   * address can be updated on the holder to change the runtime\n   * code used by all its proxies.\n   *\n   * @param implementationID ID for the implementation, used to identify the\n   * proxies that use it. Also used as the salt in the create2 call when\n   * deploying the implementation holder contract.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function createManyToOneProxyRelationship(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a many-to-one\n   * proxy relationship.\n   *\n   * @param implementationID Identifier for the implementation.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function setImplementationAddressManyToOne(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a one-to-one proxy.\n   *\n   * Note: This could work for many-to-one as well if the caller\n   * provides the implementation holder address in place of the\n   * proxy address, as they use the same access control and update\n   * mechanism.\n   *\n   * @param proxyAddress Address of the deployed proxy\n   * @param implementation Address with the runtime code for\n   * the proxy to use.\n   */\n  function setImplementationAddressOneToOne(\n    address proxyAddress,\n    address implementation\n  ) external;\n\n/* ---  Proxy Deployment  --- */\n\n  /**\n   * @dev Deploy a proxy contract with a one-to-one relationship\n   * with its implementation.\n   *\n   * The proxy will have its own implementation address which can\n   * be updated by the proxy manager.\n   *\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy should use.\n   */\n  function deployProxyOneToOne(\n    bytes32 suppliedSalt,\n    address implementation\n  ) external returns(address proxyAddress);\n\n  /**\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\n   *\n   * The proxy will call the implementation holder for every transaction to\n   * determine the address to use in calls.\n   *\n   * @param implementationID Identifier for the proxy's implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deployProxyManyToOne(\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external returns(address proxyAddress);\n\n/* ---  Queries  --- */\n\n  function isApprovedDeployer(address deployer) external view returns (bool);\n\n  /**\n   * @dev Queries the temporary storage value `_implementationHolder`.\n   * This is used in the constructor of the many-to-one proxy contract\n   * so that the create2 address is static (adding constructor arguments\n   * would change the codehash) and the implementation holder can be\n   * stored as a constant.\n   */\n  function getImplementationHolder() external view returns (address);\n\n  /**\n   * @dev Returns the address of the implementation holder contract\n   * for `implementationID`.\n   */\n  function getImplementationHolder(bytes32 implementationID) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy requested\n   * by `originator` using `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address originator,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(bytes32 implementationID) external view returns (address);\n}"
    },
    "@indexed-finance/proxies/contracts/SaltyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ---  External Libraries  --- */\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\n/* ---  Proxy Contracts  --- */\nimport \"./ManyToOneImplementationHolder.sol\";\nimport { DelegateCallProxyManyToOne } from \"./DelegateCallProxyManyToOne.sol\";\nimport { DelegateCallProxyOneToOne } from \"./DelegateCallProxyOneToOne.sol\";\n\n\nlibrary SaltyLib {\n/* ---  Constants  --- */\n  bytes32 internal constant ONE_TO_ONE_CODEHASH = keccak256(\n    type(DelegateCallProxyOneToOne).creationCode\n  );\n\n  bytes32 internal constant MANY_TO_ONE_CODEHASH = keccak256(\n    type(DelegateCallProxyManyToOne).creationCode\n  );\n\n  bytes32 internal constant IMPLEMENTATION_HOLDER_CODEHASH = keccak256(\n    type(ManyToOneImplementationHolder).creationCode\n  );\n\n/* ---  Salt Derivation  --- */\n\n  /**\n   * @dev Derives the create2 salt for a many-to-one proxy.\n   *\n   * Many different contracts in the Indexed framework may use the\n   * same implementation contract, and they all use the same init\n   * code, so we derive the actual create2 salt from a combination\n   * of the implementation ID, the address of the account requesting\n   * deployment and the user-supplied salt.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveManyToOneSalt(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        originator,\n        implementationID,\n        suppliedSalt\n      )\n    );\n  }\n\n  /**\n   * @dev Derives the create2 salt for a one-to-one proxy.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveOneToOneSalt(\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(originator, suppliedSalt));\n  }\n\n/* ---  Address Derivation  --- */\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy deployed\n   * by `deployer` (the factory) when requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address deployer,\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveOneToOneSalt(originator, suppliedSalt);\n    return Create2.computeAddress(salt, ONE_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` deployed by `deployer` (the factory)\n   * when requested by `originator` using `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address deployer,\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveManyToOneSalt(\n      originator,\n      implementationID,\n      suppliedSalt\n    );\n    return Create2.computeAddress(salt, MANY_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(\n    address deployer,\n    bytes32 implementationID\n  )\n    internal\n    pure\n    returns (address)\n  {\n    return Create2.computeAddress(\n      implementationID,\n      IMPLEMENTATION_HOLDER_CODEHASH,\n      deployer\n    );\n  }\n}"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"
    },
    "@indexed-finance/proxies/contracts/ManyToOneImplementationHolder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Stores a single implementation address which is used by\n * many proxies.\n *\n * Inspired by the DharmaUpgradeBeacon from 0age\n * dharma-eng/dharma-smart-wallet/contracts/upgradeability/DharmaUpgradeBeacon.sol\n */\ncontract ManyToOneImplementationHolder {\n/* ---  Storage  --- */\n  address internal immutable _owner;\n  address internal _implementation;\n\n/* ---  Constructor  --- */\n  constructor() public {\n    _owner = msg.sender;\n  }\n\n  /**\n   * @dev Fallback function for the contract.\n   *\n   * Used by proxies to read the implementation address and used\n   * by the proxy manager to set the implementation address.\n   *\n   * If called by the owner, reads the implementation address from\n   * calldata (must be abi-encoded) and stores it to the first slot.\n   *\n   * Otherwise, returns the stored implementation address.\n   */\n  fallback() external payable {\n    if (msg.sender != _owner) {\n      assembly {\n        mstore(0, sload(0))\n        return(0, 32)\n      }\n    }\n    assembly { sstore(0, calldataload(0)) }\n  }\n}"
    },
    "@indexed-finance/proxies/contracts/DelegateCallProxyManyToOne.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\n\n/**\n * @dev Proxy contract which uses an implementation address shared with many\n * other proxies.\n *\n * An implementation holder contract stores the upgradeable logic address.\n * The proxy contract calls the implementation holder to execute each delegated\n * transaction.\n *\n * Note: This contract does not verify that the implementation\n * address is a valid delegation target. The manager must perform\n * this safety check before updating the implementation on the holder.\n */\ncontract DelegateCallProxyManyToOne is Proxy {\n/* ---  Constants  --- */\n\n  // Address that stores the implementation address.\n  address internal immutable _implementationHolder;\n\n/* ---  Constructor  --- */\n\n  constructor() public {\n    // Calls the sender rather than receiving the address in the constructor\n    // arguments so that the address is computable using create2.\n    _implementationHolder = ProxyDeployer(msg.sender).getImplementationHolder();\n  }\n\n/* ---  Internal Overrides  --- */\n\n  /**\n   * @dev Queries the implementation address from the implementation holder.\n   */\n  function _implementation() internal override view returns (address) {\n    // Queries the implementation address from the implementation holder.\n    (bool success, bytes memory data) = _implementationHolder.staticcall(\"\");\n    require(success, string(data));\n    address implementation = abi.decode((data), (address));\n    require(implementation != address(0), \"ERR_NULL_IMPLEMENTATION\");\n    return implementation;\n  }\n}\n\ninterface ProxyDeployer {\n  function getImplementationHolder() external view returns (address);\n}"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n * \n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n * \n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     * \n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal virtual view returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     * \n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () payable external {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () payable external {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     * \n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "@indexed-finance/proxies/contracts/DelegateCallProxyOneToOne.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\n\n/**\n * @dev Upgradeable delegatecall proxy for a single contract.\n *\n * This proxy stores an implementation address which can be\n * upgraded by the proxy manager.\n *\n * The storage slot for the implementation address is:\n * `bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)`\n * This slot must not be used by the implementation contract.\n *\n * To upgrade the proxy, the manager calls the proxy with the\n * abi encoded implementation address.\n *\n * Note: This contract does not verify that the implementation\n * address is a valid delegation target. The manager must perform\n * this safety check.\n */\ncontract DelegateCallProxyOneToOne is Proxy {\n/* ---  Constants  --- */\n  address internal immutable _owner;\n\n/* ---  Constructor  --- */\n  constructor() public {\n    _owner = msg.sender ;\n  }\n\n/* ---  Internal Overrides  --- */\n\n  /**\n   * @dev Reads the implementation address from storage.\n   */\n  function _implementation() internal override view returns (address) {\n    address implementation;\n    assembly {\n      implementation := sload(\n        // bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)\n        0x913bd12b32b36f36cedaeb6e043912bceb97022755958701789d3108d33a045a\n      )\n    }\n    return implementation;\n  }\n\n  /**\n    * @dev Hook that is called before falling back to the implementation.\n    *\n    * Checks if the call is from the owner.\n    * If it is, reads the abi-encoded implementation address from calldata and stores\n    * it at the slot `bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)`,\n    * then returns with no data.\n    * If it is not, continues execution with the fallback function.\n    */\n  function _beforeFallback() internal override {\n    if (msg.sender != _owner) {\n      super._beforeFallback();\n    } else {\n      assembly {\n        sstore(\n          // bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)\n          0x913bd12b32b36f36cedaeb6e043912bceb97022755958701789d3108d33a045a,\n          calldataload(0)\n        )\n        return(0, 0)\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IPoolFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface IPoolFactory {\n  function isIPool(address pool) external view returns (bool);\n}"
    },
    "contracts/lib/UniswapV2AddressLibrary.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nlibrary UniswapV2AddressLibrary {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n}\n"
    },
    "contracts/lib/Owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\ncontract Owned {\n  event OwnerSet(address newOwner);\n\n  address internal _owner;\n\n  modifier _owner_ {\n    require(msg.sender == _owner, \"ERR_NOT_OWNER\");\n    _;\n  }\n\n  constructor(address owner) public {\n    _owner = owner;\n  }\n\n  function getOwner() external view returns (address) {\n    return _owner;\n  }\n\n  function setOwner(address owner) external _owner_ {\n    require(owner != address(0), \"ERR_NULL_ADDRESS\");\n    _owner = owner;\n    emit OwnerSet(owner);\n  }\n}"
    },
    "contracts/distribution/TreasuryVester.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract TreasuryVester {\n  using SafeMath for uint256;\n\n  address public uni;\n  address public recipient;\n\n  uint256 public vestingAmount;\n  uint256 public vestingBegin;\n  uint256 public vestingCliff;\n  uint256 public vestingEnd;\n\n  uint256 public lastUpdate;\n\n  constructor(\n    address uni_,\n    address recipient_,\n    uint256 vestingAmount_,\n    uint256 vestingBegin_,\n    uint256 vestingCliff_,\n    uint256 vestingEnd_\n  ) public {\n    require(\n      vestingBegin_ >= block.timestamp,\n      \"TreasuryVester::constructor: vesting begin too early\"\n    );\n    require(\n      vestingCliff_ >= vestingBegin_,\n      \"TreasuryVester::constructor: cliff is too early\"\n    );\n    require(\n      vestingEnd_ > vestingCliff_,\n      \"TreasuryVester::constructor: end is too early\"\n    );\n\n    uni = uni_;\n    recipient = recipient_;\n\n    vestingAmount = vestingAmount_;\n    vestingBegin = vestingBegin_;\n    vestingCliff = vestingCliff_;\n    vestingEnd = vestingEnd_;\n\n    lastUpdate = vestingBegin;\n  }\n\n  function setRecipient(address recipient_) public {\n    require(\n      msg.sender == recipient,\n      \"TreasuryVester::setRecipient: unauthorized\"\n    );\n    recipient = recipient_;\n  }\n\n  function claim() public {\n    require(\n      block.timestamp >= vestingCliff,\n      \"TreasuryVester::claim: not time yet\"\n    );\n    uint256 amount;\n    if (block.timestamp >= vestingEnd) {\n      amount = INdx(uni).balanceOf(address(this));\n    } else {\n      amount = vestingAmount.mul(block.timestamp - lastUpdate).div(\n        vestingEnd - vestingBegin\n      );\n      lastUpdate = block.timestamp;\n    }\n    INdx(uni).transfer(recipient, amount);\n  }\n}\n\ninterface INdx {\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address dst, uint256 rawAmount) external returns (bool);\n}\n"
    },
    "contracts/governance/GovernorAlpha.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract GovernorAlpha {\n  /// @notice The name of this contract\n  string public constant name = \"Indexed Governor Alpha\";\n\n  /**\n   * @notice The number of votes in support of a proposal required in order for a\n   * quorum to be reached and for a vote to succeed\n   */ \n  function quorumVotes() public pure returns (uint256) {\n    return 40_000_000e18;\n  }\n\n  function proposalThreshold() public pure returns (uint256) {\n    return 10_000_000e18;\n  }\n\n  function proposalMaxOperations() public pure returns (uint256) {\n    return 10;\n  }\n\n  function votingDelay() public pure returns (uint256) {\n    return 1;\n  }\n\n  function votingPeriod() public pure returns (uint256) {\n    return 40_320;\n  }\n\n  TimelockInterface public timelock;\n\n  NdxInterface public ndx;\n\n  uint256 public proposalCount;\n\n  struct Proposal {\n    uint256 id;\n    address proposer;\n    uint256 eta;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    bool canceled;\n    bool executed;\n    mapping(address => Receipt) receipts;\n  }\n\n  struct Receipt {\n    bool hasVoted;\n    bool support;\n    uint96 votes;\n  }\n\n  enum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n  }\n\n  mapping(uint256 => Proposal) public proposals;\n\n  mapping(address => uint256) public latestProposalIds;\n\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n    \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n  );\n\n  bytes32 public constant BALLOT_TYPEHASH = keccak256(\n    \"Ballot(uint256 proposalId,bool support)\"\n  );\n\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startBlock,\n    uint256 endBlock,\n    string description\n  );\n\n  event VoteCast(\n    address voter,\n    uint256 proposalId,\n    bool support,\n    uint256 votes\n  );\n\n  event ProposalCanceled(uint256 id);\n\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  event ProposalExecuted(uint256 id);\n\n  constructor(address timelock_, address ndx_) public {\n    timelock = TimelockInterface(timelock_);\n    ndx = NdxInterface(ndx_);\n  }\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n  ) public returns (uint256) {\n    require(\n      ndx.getPriorVotes(msg.sender, sub256(block.number, 1)) >\n        proposalThreshold(),\n      \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n    );\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(\n      targets.length != 0,\n      \"GovernorAlpha::propose: must provide actions\"\n    );\n    require(\n      targets.length <= proposalMaxOperations(),\n      \"GovernorAlpha::propose: too many actions\"\n    );\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n      );\n      require(\n        proposersLatestProposalState != ProposalState.Pending,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n      );\n    }\n\n    uint256 startBlock = add256(block.number, votingDelay());\n    uint256 endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    Proposal memory newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: targets,\n      values: values,\n      signatures: signatures,\n      calldatas: calldatas,\n      startBlock: startBlock,\n      endBlock: endBlock,\n      forVotes: 0,\n      againstVotes: 0,\n      canceled: false,\n      executed: false\n    });\n\n    proposals[newProposal.id] = newProposal;\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      startBlock,\n      endBlock,\n      description\n    );\n    return newProposal.id;\n  }\n\n  function queue(uint256 proposalId) public {\n    require(\n      state(proposalId) == ProposalState.Succeeded,\n      \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    uint256 eta = add256(block.timestamp, timelock.delay());\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        eta\n      );\n    }\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n  }\n\n  function _queueOrRevert(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) internal {\n    require(\n      !timelock.queuedTransactions(\n        keccak256(abi.encode(target, value, signature, data, eta))\n      ),\n      \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n    );\n    timelock.queueTransaction(target, value, signature, data, eta);\n  }\n\n  function execute(uint256 proposalId) public payable {\n    require(\n      state(proposalId) == ProposalState.Queued,\n      \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.executeTransaction.value(proposal.values[i])(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n    emit ProposalExecuted(proposalId);\n  }\n\n  function cancel(uint256 proposalId) public {\n    ProposalState state = state(proposalId);\n    require(\n      state != ProposalState.Executed,\n      \"GovernorAlpha::cancel: cannot cancel executed proposal\"\n    );\n\n    Proposal storage proposal = proposals[proposalId];\n    require(\n      ndx.getPriorVotes(proposal.proposer, sub256(block.number, 1)) <\n        proposalThreshold(),\n      \"GovernorAlpha::cancel: proposer above threshold\"\n    );\n\n    proposal.canceled = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.cancelTransaction(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  function getActions(uint256 proposalId)\n    public\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    )\n  {\n    Proposal storage p = proposals[proposalId];\n    return (p.targets, p.values, p.signatures, p.calldatas);\n  }\n\n  function getReceipt(uint256 proposalId, address voter)\n    public\n    view\n    returns (Receipt memory)\n  {\n    return proposals[proposalId].receipts[voter];\n  }\n\n  function state(uint256 proposalId) public view returns (ProposalState) {\n    require(\n      proposalCount >= proposalId && proposalId > 0,\n      \"GovernorAlpha::state: invalid proposal id\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n      return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n      return ProposalState.Active;\n    } else if (\n      proposal.forVotes <= proposal.againstVotes ||\n      proposal.forVotes < quorumVotes()\n    ) {\n      return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (\n      block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())\n    ) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function castVote(uint256 proposalId, bool support) public {\n    return _castVote(msg.sender, proposalId, support);\n  }\n\n  function castVoteBySig(\n    uint256 proposalId,\n    bool support,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(BALLOT_TYPEHASH, proposalId, support)\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(\n      signatory != address(0),\n      \"GovernorAlpha::castVoteBySig: invalid signature\"\n    );\n    return _castVote(signatory, proposalId, support);\n  }\n\n  function _castVote(\n    address voter,\n    uint256 proposalId,\n    bool support\n  ) internal {\n    require(\n      state(proposalId) == ProposalState.Active,\n      \"GovernorAlpha::_castVote: voting is closed\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(\n      receipt.hasVoted == false,\n      \"GovernorAlpha::_castVote: voter already voted\"\n    );\n    uint96 votes = ndx.getPriorVotes(voter, proposal.startBlock);\n\n    if (support) {\n      proposal.forVotes = add256(proposal.forVotes, votes);\n    } else {\n      proposal.againstVotes = add256(proposal.againstVotes, votes);\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n  }\n\n  function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"addition overflow\");\n    return c;\n  }\n\n  function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"subtraction underflow\");\n    return a - b;\n  }\n\n  function getChainId() internal pure returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n\ninterface TimelockInterface {\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function acceptAdmin() external;\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n}\n\ninterface NdxInterface {\n  function getPriorVotes(address account, uint256 blockNumber)\n    external\n    view\n    returns (uint96);\n}\n"
    },
    "contracts/governance/Ndx.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Ndx {\n  /// @notice EIP-20 token name for this token\n  string public constant name = \"Indexed\";\n\n  /// @notice EIP-20 token symbol for this token\n  string public constant symbol = \"NDX\";\n\n  /// @notice EIP-20 token decimals for this token\n  uint8 public constant decimals = 18;\n\n  /// @notice Total number of tokens in circulation\n  uint256 public totalSupply = 1_000_000_000e18;\n\n  mapping(address => mapping(address => uint96)) internal allowances;\n\n  mapping(address => uint96) internal balances;\n\n  mapping(address => address) public delegates;\n\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n\n  mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n  mapping(address => uint32) public numCheckpoints;\n\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n    \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n  );\n\n  bytes32 public constant DELEGATION_TYPEHASH = keccak256(\n    \"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"\n  );\n\n  bytes32 public constant PERMIT_TYPEHASH = keccak256(\n    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n  );\n\n  mapping(address => uint256) public nonces;\n\n  event DelegateChanged(\n    address indexed delegator,\n    address indexed fromDelegate,\n    address indexed toDelegate\n  );\n\n  event DelegateVotesChanged(\n    address indexed delegate,\n    uint256 previousBalance,\n    uint256 newBalance\n  );\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n\n  constructor(address account) public {\n    balances[account] = uint96(totalSupply);\n    emit Transfer(address(0), account, totalSupply);\n  }\n\n  function allowance(address account, address spender)\n    external\n    view\n    returns (uint256)\n  {\n    return allowances[account][spender];\n  }\n\n  function approve(address spender, uint256 rawAmount) external returns (bool) {\n    uint96 amount;\n    if (rawAmount == uint256(-1)) {\n      amount = uint96(-1);\n    } else {\n      amount = safe96(rawAmount, \"Ndx::approve: amount exceeds 96 bits\");\n    }\n\n    allowances[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 rawAmount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    uint96 amount;\n    if (rawAmount == uint256(-1)) {\n      amount = uint96(-1);\n    } else {\n      amount = safe96(rawAmount, \"Ndx::permit: amount exceeds 96 bits\");\n    }\n\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        rawAmount,\n        nonces[owner]++,\n        deadline\n      )\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Ndx::permit: invalid signature\");\n    require(signatory == owner, \"Ndx::permit: unauthorized\");\n    require(now <= deadline, \"Ndx::permit: signature expired\");\n\n    allowances[owner][spender] = amount;\n\n    emit Approval(owner, spender, amount);\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return balances[account];\n  }\n\n  function nonceOf(address account) external view returns (uint256) {\n    return nonces[account];\n  }\n\n  function transfer(address dst, uint256 rawAmount) external returns (bool) {\n    uint96 amount = safe96(rawAmount, \"Ndx::transfer: amount exceeds 96 bits\");\n    _transferTokens(msg.sender, dst, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 rawAmount\n  ) external returns (bool) {\n    address spender = msg.sender;\n    uint96 spenderAllowance = allowances[src][spender];\n    uint96 amount = safe96(rawAmount, \"Ndx::approve: amount exceeds 96 bits\");\n\n    if (spender != src && spenderAllowance != uint96(-1)) {\n      uint96 newAllowance = sub96(\n        spenderAllowance,\n        amount,\n        \"Ndx::transferFrom: transfer amount exceeds spender allowance\"\n      );\n      allowances[src][spender] = newAllowance;\n\n      emit Approval(src, spender, newAllowance);\n    }\n\n    _transferTokens(src, dst, amount);\n    return true;\n  }\n\n  function delegate(address delegatee) public {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(\n        DOMAIN_TYPEHASH,\n        keccak256(bytes(name)),\n        getChainId(),\n        address(this)\n      )\n    );\n    bytes32 structHash = keccak256(\n      abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Ndx::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"Ndx::delegateBySig: invalid nonce\");\n    require(now <= expiry, \"Ndx::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n  function getCurrentVotes(address account) external view returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  function getPriorVotes(address account, uint256 blockNumber)\n    public\n    view\n    returns (uint96)\n  {\n    require(\n      blockNumber < block.number,\n      \"Ndx::getPriorVotes: not yet determined\"\n    );\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n      return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint32 center = upper - (upper - lower) / 2;\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock < blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _transferTokens(\n    address src,\n    address dst,\n    uint96 amount\n  ) internal {\n    require(\n      src != address(0),\n      \"Ndx::_transferTokens: cannot transfer from the zero address\"\n    );\n    require(\n      dst != address(0),\n      \"Ndx::_transferTokens: cannot transfer to the zero address\"\n    );\n\n    balances[src] = sub96(\n      balances[src],\n      amount,\n      \"Ndx::_transferTokens: transfer amount exceeds balance\"\n    );\n    balances[dst] = add96(\n      balances[dst],\n      amount,\n      \"Ndx::_transferTokens: transfer amount overflows\"\n    );\n    emit Transfer(src, dst, amount);\n\n    _moveDelegates(delegates[src], delegates[dst], amount);\n  }\n\n  function _moveDelegates(\n    address srcRep,\n    address dstRep,\n    uint96 amount\n  ) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum > 0\n          ? checkpoints[srcRep][srcRepNum - 1].votes\n          : 0;\n        uint96 srcRepNew = sub96(\n          srcRepOld,\n          amount,\n          \"Ndx::_moveVotes: vote amount underflows\"\n        );\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum > 0\n          ? checkpoints[dstRep][dstRepNum - 1].votes\n          : 0;\n        uint96 dstRepNew = add96(\n          dstRepOld,\n          amount,\n          \"Ndx::_moveVotes: vote amount overflows\"\n        );\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    address delegatee,\n    uint32 nCheckpoints,\n    uint96 oldVotes,\n    uint96 newVotes\n  ) internal {\n    uint32 blockNumber = safe32(\n      block.number,\n      \"Ndx::_writeCheckpoint: block number exceeds 32 bits\"\n    );\n\n    if (\n      nCheckpoints > 0 &&\n      checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n    ) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint256 n, string memory errorMessage)\n    internal\n    pure\n    returns (uint32)\n  {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function safe96(uint256 n, string memory errorMessage)\n    internal\n    pure\n    returns (uint96)\n  {\n    require(n < 2**96, errorMessage);\n    return uint96(n);\n  }\n\n  function add96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function getChainId() internal pure returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n"
    },
    "contracts/governance/Timelock.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../interfaces/ITimelock.sol\";\n\n\ncontract Timelock is ITimelock {\n  using SafeMath for uint256;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  uint256 public constant override GRACE_PERIOD = 14 days;\n  uint256 public constant override MINIMUM_DELAY = 2 days;\n  uint256 public constant override MAXIMUM_DELAY = 30 days;\n\n  address public override admin;\n  address public override pendingAdmin;\n  uint256 public override delay;\n\n  mapping(bytes32 => bool) public override queuedTransactions;\n\n  constructor(address admin_, uint256 delay_) public {\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::constructor: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  fallback() external payable {}\n\n  function setDelay(uint256 delay_) public override {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setDelay: Call must come from Timelock.\"\n    );\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::setDelay: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public override {\n    require(\n      msg.sender == pendingAdmin,\n      \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n    );\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public override {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n    );\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override returns (bytes32) {\n    require(\n      msg.sender == admin,\n      \"Timelock::queueTransaction: Call must come from admin.\"\n    );\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override {\n    require(\n      msg.sender == admin,\n      \"Timelock::cancelTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable override returns (bytes memory) {\n    require(\n      msg.sender == admin,\n      \"Timelock::executeTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(\n      queuedTransactions[txHash],\n      \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockTimestamp() >= eta,\n      \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n      \"Timelock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call.value(value)(\n      callData\n    );\n    require(\n      success,\n      \"Timelock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint256) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/interfaces/ITimelock.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface ITimelock {\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  function GRACE_PERIOD() external pure returns (uint256);\n  \n  function MINIMUM_DELAY() external pure returns (uint256);\n  \n  function MAXIMUM_DELAY() external pure returns (uint256);\n\n  function admin() external view returns (address);\n\n  function pendingAdmin() external view returns (address);\n\n  function delay() external view returns (uint256);\n\n  function queuedTransactions(bytes32) external view returns (bool);\n\n  function setDelay(uint256 delay_) external;\n\n  function acceptAdmin() external;\n\n  function setPendingAdmin(address pendingAdmin_) external;\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/IDelegateCallProxyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\n *\n * An implementation identifier can be created on the proxy manager which is\n * used to specify the logic address for a particular contract type, and to\n * upgrade the implementation as needed.\n *\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\n * address.\n *\n * A many-to-one proxy is a single upgradeable implementation address that may be\n * used by many proxy contracts.\n */\ninterface DelegateCallProxyManager {\n/* ---  Events  --- */\n\n  event DeploymentApprovalGranted(address deployer);\n  event DeploymentApprovalRevoked(address deployer);\n\n  event ManyToOne_ImplementationCreated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ImplementationUpdated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ProxyDeployed(\n    bytes32 implementationID,\n    address proxyAddress\n  );\n\n  event OneToOne_ProxyDeployed(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n  event OneToOne_ImplementationUpdated(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n/* ---  Controls  --- */\n\n  /**\n   * @dev Allows `deployer` to deploy many-to-one proxies.\n   */\n  function approveDeployer(address deployer) external;\n\n  /**\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\n   */\n  function revokeDeployerApproval(address deployer) external;\n\n/* ---  Implementation Management  --- */\n\n  /**\n   * @dev Creates a many-to-one proxy relationship.\n   *\n   * Deploys an implementation holder contract which stores the\n   * implementation address for many proxies. The implementation\n   * address can be updated on the holder to change the runtime\n   * code used by all its proxies.\n   *\n   * @param implementationID ID for the implementation, used to identify the\n   * proxies that use it. Also used as the salt in the create2 call when\n   * deploying the implementation holder contract.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function createManyToOneProxyRelationship(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a many-to-one\n   * proxy relationship.\n   *\n   * @param implementationID Identifier for the implementation.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function setImplementationAddressManyToOne(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a one-to-one proxy.\n   *\n   * Note: This could work for many-to-one as well if the caller\n   * provides the implementation holder address in place of the\n   * proxy address, as they use the same access control and update\n   * mechanism.\n   *\n   * @param proxyAddress Address of the deployed proxy\n   * @param implementation Address with the runtime code for\n   * the proxy to use.\n   */\n  function setImplementationAddressOneToOne(\n    address proxyAddress,\n    address implementation\n  ) external;\n\n/* ---  Proxy Deployment  --- */\n\n  /**\n   * @dev Deploy a proxy contract with a one-to-one relationship\n   * with its implementation.\n   *\n   * The proxy will have its own implementation address which can\n   * be updated by the proxy manager.\n   *\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy should use.\n   */\n  function deployProxyOneToOne(\n    bytes32 suppliedSalt,\n    address implementation\n  ) external returns(address proxyAddress);\n\n  /**\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\n   *\n   * The proxy will call the implementation holder for every transaction to\n   * determine the address to use in calls.\n   *\n   * @param implementationID Identifier for the proxy's implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deployProxyManyToOne(\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external returns(address proxyAddress);\n\n/* ---  Queries  --- */\n\n  function isApprovedDeployer(address deployer) external view;\n\n  /**\n   * @dev Queries the temporary storage value `_implementationHolder`.\n   * This is used in the constructor of the many-to-one proxy contract\n   * so that the create2 address is static (adding constructor arguments\n   * would change the codehash) and the implementation holder can be\n   * stored as a constant.\n   */\n  function getImplementationHolder() external view returns (address);\n\n  /**\n   * @dev Returns the address of the implementation holder contract\n   * for `implementationID`.\n   */\n  function getImplementationHolder(bytes32 implementationID) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy requested\n   * by `originator` using `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address originator,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(bytes32 implementationID) external view returns (address);\n}"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Detailed {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/lib/SafeDecimalMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n// Libraries\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n  using SafeMath for uint256;\n\n  /* Number of decimal places in the representations. */\n  uint8 public constant decimals = 18;\n  uint8 public constant highPrecisionDecimals = 27;\n\n  /* The number representing 1.0. */\n  uint256 public constant UNIT = 10**uint256(decimals);\n\n  /* The number representing 1.0 for higher fidelity numbers. */\n  uint256 public constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\n  uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10 ** uint256(\n    highPrecisionDecimals - decimals\n  );\n\n  /**\n   * @return Provides an interface to UNIT.\n   */\n  function unit() external pure returns (uint256) {\n    return UNIT;\n  }\n\n  /**\n   * @return Provides an interface to PRECISE_UNIT.\n   */\n  function preciseUnit() external pure returns (uint256) {\n    return PRECISE_UNIT;\n  }\n\n  /**\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\n   * decimals.\n   *\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\n   * so that product must be less than 2**256. As this is an integer division,\n   * the internal division always rounds down. This helps save on gas. Rounding\n   * is more expensive on gas.\n   */\n  function multiplyDecimal(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    return x.mul(y) / UNIT;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of the specified precision unit.\n   *\n   * @dev The operands should be in the form of a the specified unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function _multiplyDecimalRound(\n    uint256 x,\n    uint256 y,\n    uint256 precisionUnit\n  ) private pure returns (uint256) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a precise unit.\n   *\n   * @dev The operands should be in the precise unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRoundPrecise(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a standard unit.\n   *\n   * @dev The operands should be in the standard unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRound(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _multiplyDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is a high\n   * precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\n   * this is an integer division, the result is always rounded down.\n   * This helps save on gas. Rounding is more expensive on gas.\n   */\n  function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n    /* Reintroduce the UNIT factor that will be divided out by y. */\n    return x.mul(UNIT).div(y);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * decimal in the precision unit specified in the parameter.\n   *\n   * @dev y is divided after the product of x and the specified precision unit\n   * is evaluated, so the product of x and the specified precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function _divideDecimalRound(\n    uint256 x,\n    uint256 y,\n    uint256 precisionUnit\n  ) private pure returns (uint256) {\n    uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n    if (resultTimesTen % 10 >= 5) {\n      resultTimesTen += 10;\n    }\n\n    return resultTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * standard precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and the standard precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRound(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _divideDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * high precision decimal.\n   *\n   * @dev y is divided after the product of x and the high precision unit\n   * is evaluated, so the product of x and the high precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRoundPrecise(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Convert a standard decimal representation to a high precision one.\n   */\n  function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\n    return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n  }\n\n  /**\n   * @dev Convert a high precision decimal to a standard decimal representation.\n   */\n  function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\n    uint256 quotientTimesTen = i /\n      (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n}\n"
    },
    "contracts/mocks/BaseERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n// Originally from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n// This source code has been modified from the original.\n// Subject to the MIT license.\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract BaseERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) internal _balances;\n\n  mapping (address => mapping (address => uint256)) internal _allowances;\n\n  uint256 internal _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n    * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n    * a default value of 18.\n    *\n    * To select a different value for {decimals}, use {_setupDecimals}.\n    *\n    * All three of these values are immutable: they can only be set once during\n    * construction.\n    */\n  constructor (string memory name, string memory symbol) public {\n    _name = name;\n    _symbol = symbol;\n    _decimals = 18;\n  }\n\n  /**\n    * @dev Returns the name of the token.\n    */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n    * @dev Returns the symbol of the token, usually a shorter version of the\n    * name.\n    */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n    * @dev Returns the number of decimals used to get its user representation.\n    * For example, if `decimals` equals `2`, a balance of `505` tokens should\n    * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n    *\n    * Tokens usually opt for a value of 18, imitating the relationship between\n    * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n    * called.\n    *\n    * NOTE: This information is only used for _display_ purposes: it in\n    * no way affects any of the arithmetic of the contract, including\n    * {IERC20-balanceOf} and {IERC20-transfer}.\n    */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n    * @dev See {IERC20-totalSupply}.\n    */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n    * @dev See {IERC20-balanceOf}.\n    */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n    * @dev See {IERC20-transfer}.\n    *\n    * Requirements:\n    *\n    * - `recipient` cannot be the zero address.\n    * - the caller must have a balance of at least `amount`.\n    */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  /**\n    * @dev See {IERC20-allowance}.\n    */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n    * @dev See {IERC20-approve}.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Emits an {Approval} event indicating the updated allowance. This is not\n    * required by the EIP. See the note at the beginning of {ERC20};\n    *\n    * Requirements:\n    * - `sender` and `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    * - the caller must have allowance for ``sender``'s tokens of at least\n    * `amount`.\n    */\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      msg.sender,\n      _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n    );\n    return true;\n  }\n\n  /**\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    * - `spender` must have allowance for the caller of at least\n    * `subtractedValue`.\n    */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n    );\n    return true;\n  }\n\n  /**\n    * @dev Moves tokens `amount` from `sender` to `recipient`.\n    *\n    * This is internal function is equivalent to {transfer}, and can be used to\n    * e.g. implement automatic token fees, slashing mechanisms, etc.\n    *\n    * Emits a {Transfer} event.\n    *\n    * Requirements:\n    *\n    * - `sender` cannot be the zero address.\n    * - `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /**\n    * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n    *\n    * This is internal function is equivalent to `approve`, and can be used to\n    * e.g. set automatic allowances for certain subsystems, etc.\n    *\n    * Emits an {Approval} event.\n    *\n    * Requirements:\n    *\n    * - `owner` cannot be the zero address.\n    * - `spender` cannot be the zero address.\n    */\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n    * @dev Sets {decimals} to a value other than the default one of 18.\n    *\n    * WARNING: This function should only be called from the constructor. Most\n    * applications that interact with token contracts will not expect\n    * {decimals} to ever change, and may work incorrectly if it does.\n    */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n    * @dev Hook that is called before any transfer of tokens. This includes\n    * minting and burning.\n    *\n    * Calling conditions:\n    *\n    * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n    * will be to transferred to `to`.\n    * - when `from` is zero, `amount` tokens will be minted for `to`.\n    * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n    * - `from` and `to` are never both zero.\n    *\n    * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n    */\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./BaseERC20.sol\";\n\n\ncontract MockERC20 is BaseERC20 {\n  constructor(\n    string memory name,\n    string memory symbol\n  ) public BaseERC20(name, symbol) {}\n\n  // Mocks WETH deposit fn\n  function deposit() external payable {\n    _mint(msg.sender, msg.value);\n  }\n\n  function getFreeTokens(address to, uint256 amount) public {\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n}"
    },
    "contracts/mocks/MockPoolFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../interfaces/IPoolFactory.sol\";\n\n\ncontract MockPoolFactory {\n  mapping(address => bool) public isIPool;\n\n  function addIPool(address poolAddress) public {\n    isIPool[poolAddress] = true;\n  }\n}"
    },
    "contracts/mocks/MockTimelock.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../interfaces/ITimelock.sol\";\n\n\n/**\n * Overrides the minimum delay\n */\ncontract MockTimelock is ITimelock {\n  using SafeMath for uint256;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  uint256 public constant override GRACE_PERIOD = 14 days;\n  uint256 public constant override MINIMUM_DELAY = 20 minutes;\n  uint256 public constant override MAXIMUM_DELAY = 30 days;\n\n  address public override admin;\n  address public override pendingAdmin;\n  uint256 public override delay;\n\n  mapping(bytes32 => bool) public override queuedTransactions;\n\n  constructor(address admin_, uint256 delay_) public {\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::constructor: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  fallback() external payable {}\n\n  function setDelay(uint256 delay_) public override {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setDelay: Call must come from Timelock.\"\n    );\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"Timelock::setDelay: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n    );\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public override {\n    require(\n      msg.sender == pendingAdmin,\n      \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n    );\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public override {\n    require(\n      msg.sender == address(this),\n      \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n    );\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override returns (bytes32) {\n    require(\n      msg.sender == admin,\n      \"Timelock::queueTransaction: Call must come from admin.\"\n    );\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override {\n    require(\n      msg.sender == admin,\n      \"Timelock::cancelTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable override returns (bytes memory) {\n    require(\n      msg.sender == admin,\n      \"Timelock::executeTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(\n      queuedTransactions[txHash],\n      \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockTimestamp() >= eta,\n      \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n      \"Timelock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call.value(value)(\n      callData\n    );\n    require(\n      success,\n      \"Timelock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint256) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}